@page
@model pto.track.Pages.AbsencesSchedulerModel
@{
    ViewData["Title"] = "Absence Scheduler View";
}

<script src="~/lib/daypilot/daypilot-all.min.js" asp-append-version="true"></script>

<style>
    .disabled-row {
        background-color: #eeeeee !important;
        cursor: not-allowed !important;
        pointer-events: none;
    }
</style>

<div class="left">
    <div id="datepicker"></div>
</div>
<div class="right">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; gap: 15px;">
        <div class="buttons">
            <button id="previous">Previous</button>
            <button id="today">Today</button>
            <button id="next">Next</button>
        </div>
        <div id="statusFilters"
            style="display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: #f5f5f5; border-radius: 4px;">
            <span style="font-weight: 600; margin-right: 5px;">Show:</span>
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; font-size: 13px;">
                <input type="checkbox" id="filterPending" value="Pending" checked
                    style="width: 16px; height: 16px; accent-color: #ffa500;">
                <span>Pending</span>
            </label>
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; font-size: 13px;">
                <input type="checkbox" id="filterApproved" value="Approved" checked
                    style="width: 16px; height: 16px; accent-color: #6aa84f;">
                <span>Approved</span>
            </label>
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; font-size: 13px;">
                <input type="checkbox" id="filterRejected" value="Rejected" checked
                    style="width: 16px; height: 16px; accent-color: #cc4125;">
                <span>Rejected</span>
            </label>
            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; font-size: 13px;">
                <input type="checkbox" id="filterCancelled" value="Cancelled" checked
                    style="width: 16px; height: 16px; accent-color: #999999;">
                <span>Cancelled</span>
            </label>
        </div>
    </div>
    <div id="scheduler"></div>
</div>

<script type="module">
    import {
        getStatusColor,
        buildAbsencesUrl,
        determineUserRole,
        getDefaultStatusFilters,
        getVisibleFilters,
        updateSelectedStatusesFromCheckboxes,
        isUserManagerOrApprover,
        canCreateAbsenceForResource,
        getResourceSelectionMessage,
        buildContextMenuItems,
        getSchedulerRowColor,
        shouldAllowSelection,
        getCellCssClass
    } from '/js/calendar-functions.mjs';

    const scheduler = new DayPilot.Scheduler("scheduler", {
        startDate: DayPilot.Date.today().firstDayOfWeek(1),
        days: 5,
        scale: "Day",
        width: "100%",
        height: 500,
        rowHeaderWidth: 200,
        cellWidth: 200,
        timeHeaders: [
            { groupBy: "Month", format: "MMMM yyyy" },
            { groupBy: "Day", format: "ddd M/d" }
        ],
        eventMoveHandling: "Disabled",
        eventResizeHandling: "Disabled",
        treeEnabled: true,
        timeRangeSelectedHandling: "Enabled",
        onBeforeRowHeaderRender: args => {
            if (typeof app === 'undefined' || !app.state || !app.state.currentUser) return;
            const isAdmin = app.state.currentUser?.roles?.includes("Admin") || false;
            const isManager = app.state.isManager || false;
            const isApprover = app.state.currentUser?.isApprover || false;

            if (!shouldAllowSelection(app.state.currentEmployeeId, args.row.id, isManager, isAdmin, isApprover)) {
                args.row.cssClass = "disabled-row";
            }
        },
        onBeforeCellRender: args => {
            if (typeof app === 'undefined' || !app.state || !app.state.currentUser) return;
            
            const isAdmin = app.state.currentUser?.roles?.includes("Admin") || false;
            const isManager = app.state.isManager || false;
            const isApprover = app.state.currentUser?.isApprover || false;

            const cssClass = getCellCssClass(
                args.cell.start, 
                DayPilot.Date.today(), 
                app.state.currentEmployeeId, 
                args.cell.resource, 
                isManager, 
                isAdmin, 
                isApprover
            );

            if (cssClass) {
                args.cell.cssClass = cssClass;
            }
        },
        onTimeRangeSelected: async (args) => {
            // Prevent selection of past dates
            if (args.start < DayPilot.Date.today()) {
                scheduler.clearSelection();
                return;
            }

            // Check if employee can create absence for this resource
            const isAdmin = app.state.currentUser?.roles?.includes("Admin") || false;
            const isManager = app.state.isManager || false;
            const isApprover = app.state.currentUser?.isApprover || false;

            if (!shouldAllowSelection(app.state.currentEmployeeId, args.resource, isManager, isAdmin, isApprover)) {
                scheduler.clearSelection();
                return;
            }

            // Calculate the date range
            const startDate = args.start;
            const endDate = args.end;

            // Generate time slots for working hours (08:00 - 18:00)
            const timeSlots = [];
            for (let h = 8; h <= 18; h++) {
                const hour = h < 10 ? `0${h}` : `${h}`;
                timeSlots.push({ name: `${hour}:00`, id: `${hour}:00` });
                if (h < 18) {
                    timeSlots.push({ name: `${hour}:30`, id: `${hour}:30` });
                }
            }

            const form = [
                { name: "Start Date", id: "start", type: "date", dateFormat: "M/d/yyyy" },
                { name: "End Date", id: "end", type: "date", dateFormat: "M/d/yyyy" },
                { name: "Start Time (first day)", id: "startTime", type: "select", options: timeSlots },
                { name: "End Time (last day)", id: "endTime", type: "select", options: timeSlots },
                { name: "Reason", id: "reason", type: "textarea" }
            ];

            const data = {
                start: startDate,
                end: endDate.addDays(-1),
                startTime: "08:00",
                endTime: "17:00",
                reason: ""
            };

            const modal = await DayPilot.Modal.form(form, data);
            scheduler.clearSelection();
            if (modal.canceled) {
                return;
            }

            // Combine date with time
            const [startHour, startMinute] = modal.result.startTime.split(':');
            const [endHour, endMinute] = modal.result.endTime.split(':');

            const modalStart = new DayPilot.Date(modal.result.start);
            const modalEnd = new DayPilot.Date(modal.result.end);

            const absenceStart = modalStart.addHours(parseInt(startHour)).addMinutes(parseInt(startMinute));
            const absenceEnd = modalEnd.addHours(parseInt(endHour)).addMinutes(parseInt(endMinute));

            const absence = {
                start: absenceStart.toString(),
                end: absenceEnd.toString(),
                employeeId: parseInt(args.resource, 10),
                reason: modal.result.reason
            };

            console.log("Sending absence request:", absence);

            try {
                const { data } = await DayPilot.Http.post(`/api/absences`, absence);

                scheduler.events.add({
                    start: data.start,
                    end: data.end,
                    id: data.id,
                    text: data.reason,
                    resource: data.employeeId,
                    barColor: getStatusColor(data.status),
                    data: data
                });
            } catch (error) {
                console.error("Error creating absence:", error);
                const errorMsg = error.request?.responseText || error.message || "Unknown error";
                console.error("Error details:", errorMsg);
                await DayPilot.Modal.alert(`Failed to create absence: ${errorMsg}`);
            }

        },
        onEventClick: async (args) => {
            // Disabled - using context menu instead
            return;
        },
        onBeforeEventRender: args => {
            const status = args.data.status || args.data.data?.status;
            args.data.backColor = getStatusColor(status);
            args.data.borderColor = "darker";
            args.data.fontColor = "#ffffff";

            // Add ellipsis menu icon
            args.data.areas = [];
            args.data.areas.push({
                right: 2,
                top: 2,
                width: 24,
                height: 24,
                html: "<div style='color: white; font-weight: bold; font-size: 18px; line-height: 24px; text-align: center; cursor: pointer; padding: 3px;'>â‹¯</div>",
                toolTip: "Actions",
                onClick: async args => {
                    const e = args.source;
                    const absence = e.data.data || e.data;

                    const userContext = {
                        currentEmployeeId: app.state.currentEmployeeId,
                        isAdmin: app.state.currentUser?.role?.toLowerCase() === 'admin' ||
                            app.state.currentUser?.roles?.some(r => r.toLowerCase() === 'admin') || false,
                        isManager: app.state.currentUser?.role?.toLowerCase() === 'manager' ||
                            app.state.currentUser?.roles?.some(r => r.toLowerCase() === 'manager') || false,
                        isApprover: app.state.currentUser?.isApprover ||
                            app.state.currentUser?.roles?.some(r => r.toLowerCase() === 'approver') || false
                    };

                    // Build menu items and wire up action handlers
                    const menuItems = buildContextMenuItems(absence, userContext, e);
                    menuItems.forEach(item => {
                        if (item.onClick) {
                            const originalOnClick = item.onClick;
                            item.onClick = async function (args) {
                                const result = originalOnClick();
                                if (result && result.action) {
                                    await app.handleMenuAction(result.action, result.absence, e);
                                }
                            };
                        }
                    });

                    const menu = new DayPilot.Menu({
                        items: menuItems
                    });
                    menu.show(e);
                    args.preventDefault();
                    args.stopPropagation();
                    return false;
                }
            });
        },
    });
    // scheduler.init() moved to bottom to ensure app is defined

    const datepicker = new DayPilot.Navigator("datepicker", {
        selectMode: "Day", // Select by day
        showMonths: 3,
        skipMonths: 3,
        weekStarts: 1, // Start on Monday
        onTimeRangeSelected: args => {
            scheduler.update({
                startDate: args.start,
            });
            app.loadSchedulerData();
        },
        onVisibleRangeChanged: args => {
            app.loadDatePickerData();
        }
    });
    // datepicker.init() moved to bottom to ensure app is defined

    const app = {
        elements: {
            previous: document.getElementById("previous"),
            today: document.getElementById("today"),
            next: document.getElementById("next"),
            filterPending: document.getElementById("filterPending"),
            filterApproved: document.getElementById("filterApproved"),
            filterRejected: document.getElementById("filterRejected"),
            filterCancelled: document.getElementById("filterCancelled")
        },
        state: {
            selectedStatuses: ["Pending", "Approved", "Rejected", "Cancelled"],
            currentEmployeeId: null,
            isManager: false,
            currentUser: null,
            isMockMode: false
        },
        async init() {
            // Load current user information
            await this.loadCurrentUser();

            // Initialize checkboxes based on role
            this.initializeCheckboxes();

            this.loadSchedulerData();
            this.loadDatePickerData();
            this.initEventHandlers();
        },
        initializeCheckboxes() {
            // Determine which checkboxes should be available based on role
            const isAdmin = this.state.currentUser?.roles?.includes("Admin");
            const isManagerOrApprover = this.state.isManager;
            const isEmployee = !isAdmin && !isManagerOrApprover;

            // First, ensure all checkboxes are visible (reset state)
            this.elements.filterPending.parentElement.style.display = "flex";
            this.elements.filterApproved.parentElement.style.display = "flex";
            this.elements.filterRejected.parentElement.style.display = "flex";
            this.elements.filterCancelled.parentElement.style.display = "flex";

            // Hide/show checkboxes based on role
            if (isEmployee) {
                // Employees can see ALL approved absences, but only their own pending/rejected/cancelled
                this.elements.filterPending.checked = false;
                this.elements.filterApproved.checked = true;
                this.elements.filterRejected.checked = false;
                this.elements.filterCancelled.checked = false;
                this.state.selectedStatuses = ["Approved"];
            } else if (isManagerOrApprover && !isAdmin) {
                // Managers/Approvers mainly care about Pending (to approve) and Approved (to verify)
                this.elements.filterPending.checked = true;
                this.elements.filterApproved.checked = true;
                this.elements.filterRejected.checked = false;
                this.elements.filterCancelled.checked = false;
                // Hide rejected and cancelled for managers/approvers
                this.elements.filterRejected.parentElement.style.display = "none";
                this.elements.filterCancelled.parentElement.style.display = "none";
                this.state.selectedStatuses = ["Pending", "Approved"];
            } else if (isAdmin) {
                // Admins see everything by default
                this.elements.filterPending.checked = true;
                this.elements.filterApproved.checked = true;
                this.elements.filterRejected.checked = true;
                this.elements.filterCancelled.checked = true;
                this.state.selectedStatuses = ["Pending", "Approved", "Rejected", "Cancelled"];
                console.log("initializeCheckboxes - Admin mode, selectedStatuses:", this.state.selectedStatuses);
            }
        },
        async loadCurrentUser() {
            try {
                const response = await DayPilot.Http.get("/api/currentuser");
                if (response.data) {
                    this.state.currentUser = response.data;
                    this.state.currentEmployeeId = response.data.id;
                    this.state.isMockMode = response.data.isMockMode || false;
                    this.state.isManager = response.data.isApprover ||
                        response.data.roles?.some(r =>
                            r.toLowerCase() === 'manager' ||
                            r.toLowerCase() === 'approver'
                        );

                    console.log("Current user:", this.state.currentUser);
                    console.log("Is manager/approver:", this.state.isManager);
                    console.log("Mock mode:", this.state.isMockMode);
                }
            } catch (error) {
                console.warn("Could not load current user, using defaults:", error);
                // Fallback for development without authentication
                this.state.currentEmployeeId = 1;
            }
        },
        async loadSchedulerData() {
            const start = scheduler.visibleStart();
            const end = scheduler.visibleEnd();

            console.log("loadSchedulerData - selectedStatuses:", this.state.selectedStatuses);
            let absencesUrl = `/api/absences?start=${start}&end=${end}`;

            // Add all selected statuses to the query (using array notation for ASP.NET Core)
            this.state.selectedStatuses.forEach(status => {
                absencesUrl += `&status[]=${status}`;
            });
            console.log("loadSchedulerData - URL:", absencesUrl);

            // For employees: Show ALL approved absences, but only their own pending/rejected/cancelled
            const isEmployee = !this.state.isManager && !this.state.currentUser?.roles?.includes("Admin");
            if (isEmployee) {
                // Check if user is viewing ONLY approved absences
                const onlyApproved = this.state.selectedStatuses.length === 1 &&
                    this.state.selectedStatuses[0] === "Approved";

                // If viewing any non-approved status, filter to employee's own requests
                if (!onlyApproved) {
                    absencesUrl += `&employeeId=${this.state.currentEmployeeId}`;
                }
                // If viewing ONLY approved, don't add employeeId filter (show everyone's)
            }

            const promiseAbsences = DayPilot.Http.get(absencesUrl);
            const promiseResources = DayPilot.Http.get("/api/resources");

            try {
                const [{ data: resources }, { data: absences }] = await Promise.all([promiseResources, promiseAbsences]);

                console.log("loadSchedulerData - API returned", absences.length, "absences");
                console.log("loadSchedulerData - Absence statuses:", absences.map(a => a.status));

                // Map absences to scheduler events
                const events = absences.map(a => ({
                    id: a.id,
                    start: a.start,
                    end: a.end,
                    text: a.reason,
                    resource: a.employeeId,
                    barColor: getStatusColor(a.status),
                    data: a
                }));

                console.log("loadSchedulerData - Updating scheduler with", events.length, "events");

                scheduler.update({
                    resources,
                    events
                });
            } catch (error) {
                console.error("Error loading scheduler data:", error);
                await DayPilot.Modal.alert("Failed to load data. Please check the console for details.");
            }
        },
        async loadDatePickerData() {
            const start = datepicker.visibleStart();
            const end = datepicker.visibleEnd();

            let absencesUrl = `/api/absences?start=${start}&end=${end}`;

            // Add all selected statuses to the query (using array notation for ASP.NET Core)
            this.state.selectedStatuses.forEach(status => {
                absencesUrl += `&status[]=${status}`;
            });

            // For employees: Show ALL approved absences, but only their own pending/rejected/cancelled
            const isEmployee = !this.state.isManager && !this.state.currentUser?.roles?.includes("Admin");
            if (isEmployee) {
                // Check if user is viewing ONLY approved absences
                const onlyApproved = this.state.selectedStatuses.length === 1 &&
                    this.state.selectedStatuses[0] === "Approved";

                // If viewing any non-approved status, filter to employee's own requests
                if (!onlyApproved) {
                    absencesUrl += `&employeeId=${this.state.currentEmployeeId}`;
                }
                // If viewing ONLY approved, don't add employeeId filter (show everyone's)
            }

            const { data } = await DayPilot.Http.get(absencesUrl);

            const events = data.map(a => ({
                start: a.start,
                end: a.end,
                text: a.reason,
                barColor: getStatusColor(a.status)
            }));

            datepicker.update({ events });
        },
        async handleMenuAction(action, absence, event) {
            switch (action) {
                case 'viewDetails':
                    await this.viewDetails(absence);
                    break;
                case 'editReason':
                    await this.editReason(absence, event);
                    break;
                case 'approve':
                    await this.approveAbsence(absence);
                    break;
                case 'reject':
                    await this.rejectAbsence(absence);
                    break;
                case 'delete':
                    await this.deleteAbsence(absence, event);
                    break;
            }
        },
        async viewDetails(absence) {
            const form = [
                { name: "Employee", id: "employeeName", disabled: true },
                { name: "Start", id: "start", type: "datetime", disabled: true },
                { name: "End", id: "end", type: "datetime", disabled: true },
                { name: "Reason", id: "reason", type: "textarea", disabled: true },
                { name: "Status", id: "status", disabled: true },
                { name: "Requested", id: "requestedDate", type: "date", disabled: true },
            ];

            if (absence.approverName) {
                form.push({ name: "Approver", id: "approverName", disabled: true });
                form.push({ name: "Approved Date", id: "approvedDate", type: "date", disabled: true });
            }

            if (absence.approvalComments) {
                form.push({ name: "Comments", id: "approvalComments", type: "textarea", disabled: true });
            }

            const formData = {
                employeeName: absence.employeeName,
                start: absence.start,
                end: absence.end,
                reason: absence.reason,
                status: absence.status,
                requestedDate: absence.requestedDate ? absence.requestedDate.split('T')[0] : null,
                approverName: absence.approverName,
                approvedDate: absence.approvedDate ? absence.approvedDate.split('T')[0] : null,
                approvalComments: absence.approvalComments
            };

            await DayPilot.Modal.form(form, formData);
        },
        async editReason(absence, event) {
            const modal = await DayPilot.Modal.prompt("Edit reason:", absence.reason);
            if (modal.canceled) return;

            const updateData = {
                start: absence.start,
                end: absence.end,
                reason: modal.result
            };

            await DayPilot.Http.put(`/api/absences/${absence.id}`, updateData);

            scheduler.events.update({
                ...event.data,
                reason: modal.result,
                text: modal.result
            });

            await this.loadSchedulerData();
        },
        async approveAbsence(absence) {
            const modal = await DayPilot.Modal.prompt("Approve this absence request? (Optional comment):");
            if (modal.canceled) return;

            const approvalData = {
                approverId: this.state.currentEmployeeId,
                comments: modal.result
            };

            await DayPilot.Http.post(`/api/absences/${absence.id}/approve`, approvalData);
            await this.loadSchedulerData();
        },
        async rejectAbsence(absence) {
            const modal = await DayPilot.Modal.prompt("Rejection reason:");
            if (modal.canceled || !modal.result) return;

            const rejectionData = {
                approverId: this.state.currentEmployeeId,
                reason: modal.result
            };

            await DayPilot.Http.post(`/api/absences/${absence.id}/reject`, rejectionData);
            await this.loadSchedulerData();
        },
        async deleteAbsence(absence, event) {
            const modal = await DayPilot.Modal.confirm("Delete this absence request?");
            if (modal.canceled) return;

            await DayPilot.Http.delete(`/api/absences/${absence.id}`);
            scheduler.events.remove(event);
            await this.loadSchedulerData();
        },
        addHandlers() {
            app.elements.previous.addEventListener("click", () => {
                const currentStart = scheduler.startDate;
                scheduler.update({
                    startDate: currentStart.addDays(-7) // Go back 1 week
                });
                app.loadSchedulerData();
            });
            app.elements.next.addEventListener("click", () => {
                const currentStart = scheduler.startDate;
                scheduler.update({
                    startDate: currentStart.addDays(7) // Go forward 1 week
                });
                app.loadSchedulerData();
            });
            app.elements.today.addEventListener("click", () => {
                scheduler.update({
                    startDate: DayPilot.Date.today().firstDayOfWeek(1) // Jump to current week
                });
                app.loadSchedulerData();
            });

            // Checkbox filter handlers
            const updateFilters = () => {
                console.log("[updateFilters] Checkbox states:", {
                    pending: app.elements.filterPending.checked,
                    approved: app.elements.filterApproved.checked,
                    rejected: app.elements.filterRejected.checked,
                    cancelled: app.elements.filterCancelled.checked
                });
                app.state.selectedStatuses = [];
                if (app.elements.filterPending.checked) app.state.selectedStatuses.push("Pending");
                if (app.elements.filterApproved.checked) app.state.selectedStatuses.push("Approved");
                if (app.elements.filterRejected.checked) app.state.selectedStatuses.push("Rejected");
                if (app.elements.filterCancelled.checked) app.state.selectedStatuses.push("Cancelled");
                console.log("[updateFilters] selectedStatuses:", app.state.selectedStatuses);

                app.loadSchedulerData();
                app.loadDatePickerData();
            };

            app.elements.filterPending.addEventListener("change", updateFilters);
            app.elements.filterApproved.addEventListener("change", updateFilters);
            app.elements.filterRejected.addEventListener("change", updateFilters);
            app.elements.filterCancelled.addEventListener("change", updateFilters);
        },
        initEventHandlers() {
            this.addHandlers();
        }
    };

    scheduler.init();
    datepicker.init();
    app.init();</script>