# Azure Pipeline for PTO Track

trigger:
  branches:
    include:
      - main

variables:
  - group: "DevOps Automation Accounts"
  - group: "ASBDotNetWebApps-DEV"

  - name: "dotnetVersion"
    value: "9.0.100"

  - name: "efToolVersion"
    value: "9.0.*"

  - name: "nodeVersion"
    value: "20.x"

  - name: "typescriptPath"
    value: 'C:\admin\typescript-5.9.3.tgz'

  - name: "esbuildPath"
    value: 'C:\admin\esbuild-0.27.1.tgz'

  - name: "solutionPath"
    value: "**/pto.track.sln"

  - name: "projectPath"
    value: "**/pto.track.csproj"

  - name: "appName"
    value: "pto.track"

  - name: "tempFolder"
    value: 'c:\self-contained_apps\$(appName)_temp'

  - name: "deploymentFolder"
    value: 'c:\self-contained_apps\$(appName)\'

  - name: "deploymentBackupFolder"
    value: 'c:\self-contained_apps\$(appName)_backup\'

  - name: "executablePath"
    value: '$(deploymentFolder)$(appName).exe'

  - name: "serviceName"
    value: "PTO_Track_Service"

  - name: "appPoolName"
    value: "pto-track"

  - name: "serviceDescription"
    value: "PTO Track .NET Core Web Application"

  - name: "webConfigPath"
    value: 'c:\self-contained_apps\$(appName)\web.config'

  - name: "forwardedHttpUrl"
    value: "http://localhost:5139"

  - name: "forwardedHttpsUrl"
    value: "https://localhost:7241"

  # additional variables are pulled from the UI

pool:
  name: DVO

stages:
  - stage: Build
    displayName: "Build Solution"
    jobs:
      - job: Build

        steps:
          - task: UseDotNet@2
            displayName: "Ensure .NET SDK 9.0 Installed"
            condition: false
            inputs:
              packageType: "sdk"
              useGlobalJson: true
              includePreviewVersions: false
              performMultiLevelLookup: true # checks for local installs

          - task: DotNetCoreCLI@2
            displayName: "Ensure dotnet-ef is Installed"
            condition: false
            inputs:
              command: "custom"
              custom: "tool"
              arguments: install --global dotnet-ef --version $(efToolVersion)

          - script: node --version
            displayName: "Check Node.js on agent"

          

          - script: npm ci --prefix pto.track
            displayName: "Install frontend dependencies (pto.track)"

          - script: npm run build:js --prefix pto.track
            displayName: "Build frontend assets (pto.track)"

          - task: DotNetCoreCLI@2
            displayName: "Restore NuGet Packages"
            inputs:
              command: "restore"
              projects: "$(solutionPath)"

          - task: DotNetCoreCLI@2
            displayName: "Build Project"
            inputs:
              command: "build"
              projects: "$(solutionPath)"
              arguments: "--configuration Release --no-restore"

  - stage: Test
    displayName: "Run Tests and Coverage"
    dependsOn: Build
    jobs:
      - job: Test
        steps:
          - checkout: self

          - script: node --version
            displayName: "Check Node.js on agent (Test Job)"          

          - script: npm --version
            displayName: "Check npm on agent (Test Job)"
            
          # Run JavaScript tests (Jest). Puppeteer Chromium download is skipped
          # to avoid headless/browser installs on restricted build agents.
          # add these back in after downgrading npm
          #- script: |
          #    npm ci --prefix pto.track.tests.js
          #  displayName: "Install JS test dependencies (pto.track.tests.js)"
          #  env:
          #    PUPPETEER_SKIP_DOWNLOAD: true

          #- script: |
          #    npm test --prefix pto.track.tests.js --silent
          #  displayName: "Run JavaScript tests (pto.track.tests.js)"
          #  env:
          #    PUPPETEER_SKIP_DOWNLOAD: true

          - task: DotNetCoreCLI@2
            displayName: "Test Services"
            inputs:
              testRunTitle: "Test Services"
              command: "test"
              projects: "**/*.tests.csproj"
              arguments: '--configuration Release --logger "trx;LogFileName=services_tests.trx" /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/coverage/ --results-directory "$(Build.SourcesDirectory)\TestResults\services"'
              publishTestResults: false # handled in arguments

          - task: DotNetCoreCLI@2
            displayName: "Test App"
            inputs:
              testRunTitle: "Test App"
              command: "test"
              projects: "**/pto.track.tests.csproj"
              arguments: '--configuration Release --logger "trx;LogFileName=app_tests.trx" /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/coverage/ --results-directory "$(Build.SourcesDirectory)\TestResults\app"'
              publishTestResults: false # handled in arguments

          - task: DotNetCoreCLI@2
            displayName: "Test Data"
            inputs:
              testRunTitle: "Test Data"
              command: "test"
              projects: "**/pto.track.data.tests.csproj"
              arguments: '--configuration Release --logger "trx;LogFileName=data_tests.trx" /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/coverage/ --results-directory "$(Build.SourcesDirectory)\TestResults\data"'
              publishTestResults: false # handled in arguments

          - task: PublishTestResults@2
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "**/TestResults/**/*.trx"
              mergeTestResults: true
              testRunTitle: "Dotnet Tests"

          - task: PublishCodeCoverageResults@1
            inputs:
              codeCoverageTool: "Cobertura"
              summaryFileLocation: "$(Build.SourcesDirectory)/TestResults/coverage/coverage.cobertura.xml"
              reportDirectory: "$(Build.SourcesDirectory)/TestResults/coverage"

          - task: PublishBuildArtifacts@1
            condition: false
            inputs:
              pathToPublish: "$(System.DefaultWorkingDirectory)/pto.track.tests.js/save-results.html"
              artifactName: "JavaScriptTestReport"
              publishLocation: "Container"

  - stage: Analyze
    displayName: "Run Analyzers and Metrics"
    dependsOn: Test
    jobs:
      - job: Analyze
        steps:
          - task: PowerShell@2
            displayName: "Run Roslyn Analyzers"
            inputs:
              filePath: "./scripts/run-analyzers.ps1"
              arguments: "-Execute"

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(System.DefaultWorkingDirectory)/artifacts/analyzers"
              artifactName: "analyzers"
              publishLocation: "Container"

          - task: DotNetCoreCLI@2
            displayName: "Build metrics-runner (console)"
            inputs:
              command: "build"
              projects: "**/metrics-runner.csproj"
              arguments: "--configuration Release"

          - task: DotNetCoreCLI@2
            displayName: "Run metrics-runner (console)"
            inputs:
              command: "run"
              projects: "**/metrics-runner"
              arguments: "-- '$(Build.SourcesDirectory)'"

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(System.DefaultWorkingDirectory)/artifacts/metrics"
              artifactName: "metrics"
              publishLocation: "Container"

  - stage: Publish
    displayName: "Publish Standalone App"
    dependsOn: Analyze
    jobs:
      - job: Publish
        steps:
          - checkout: none
          - download: current

          - task: DotNetCoreCLI@2
            displayName: "Generate Self-Contained App"
            inputs:
              command: "publish"
              publishWebProjects: false
              projects: "$(projectPath)"
              arguments: >
                --configuration Release
                --runtime win-x64
                --self-contained true
                --output $(Build.ArtifactStagingDirectory)/publish

          - task: PublishBuildArtifacts@1
            displayName: "Publish Build Artifact"
            inputs:
              PathtoPublish: "$(Build.ArtifactStagingDirectory)/publish"
              ArtifactName: "build_artifact"

  - stage: DeployDev
    displayName: "Deploy to Development Server"
    dependsOn: Publish
    jobs:
      - job: Deploy

        steps:
          - checkout: none
          - download: current

          - task: PowerShellOnTargetMachines@3
            displayName: "Check IIS Installation"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                $iisFeature = Get-WindowsFeature -Name Web-Server
                if (-not $iisFeature.Installed) {
                    Write-Error "IIS (Web-Server) is not installed. Deployment cannot continue."
                    exit 1
                }
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Stop and remove current service"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |

                if (Get-Service -Name $(serviceName)) {
                  Write-Host "Service $(serviceName) exists. Stopping and removing..."
                  Stop-Service -Name $(serviceName) -Force -ErrorAction SilentlyContinue
                  sc.exe delete $(serviceName)                
                  Write-Host "Service $(serviceName) was stopped and removed."
                } else {
                  Write-Host "Service $(serviceName) did not exist OR there was an error getting the service."
                }
              CommunicationProtocol: "Http"

          - task: WindowsMachineFileCopy@2
            displayName: "Copy Build Artifact to Web Server"
            inputs:
              SourcePath: "$(Pipeline.Workspace)/build_artifact/pto.track.zip"
              MachineNames: "$(webServerDev)"
              AdminUserName: "$(automationAcctName)"
              AdminPassword: "$(automationAcctPass)"
              TargetPath: '\\$(webServerDev)\$(tempFolder)\'
              CleanTargetBeforeCopy: true

          - task: PowerShellOnTargetMachines@3
            displayName: "Extract Artifact"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                $zip = Get-ChildItem -Path $(tempFolder)\ -Recurse | where {$_.Name -match ".zip"}
                $zip | Expand-Archive -DestinationPath $(tempFolder)\
                $zip | Remove-Item
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Set ASPNETCORE_ENVIRONMENT=$(pto-track-env) (Machine)"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                Write-Host "Setting ASPNETCORE_ENVIRONMENT=$(pto-track-env) at Machine scope"
                [Environment]::SetEnvironmentVariable("ASPNETCORE_ENVIRONMENT", "$(pto-track-env)", "Machine")
                $envVal = [Environment]::GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT", "Machine")
                Write-Host "ASPNETCORE_ENVIRONMENT (Machine) now: $envVal"
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Set ConnectionStrings__PtoTrackDbContext from variable group"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                Write-Host "Setting ConnectionStrings__PtoTrackDbContext at Machine scope"
                if (-not $env:sqlConnectionString -and -not "$(sqlConnectionString)") {
                  Write-Error "sqlConnectionString variable is not defined"
                }
                $conn = "$(sqlConnectionString)"
                if (-not $conn) { $conn = $env:sqlConnectionString }
                [Environment]::SetEnvironmentVariable("ConnectionStrings__PtoTrackDbContext", $conn, "Machine")
                $current = [Environment]::GetEnvironmentVariable("ConnectionStrings__PtoTrackDbContext", "Machine")
                if ($current) {
                  Write-Host "ConnectionStrings__PtoTrackDbContext set. Length: $($current.Length)"
                } else {
                  Write-Error "Failed to set ConnectionStrings__PtoTrackDbContext"
                }
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Replace Previous App Files/Folders"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                if (Test-Path $(deploymentBackupFolder)){
                  Remove-Item $(deploymentBackupFolder) -Recurse -Force
                }
                Move-Item -Path $(deploymentFolder) -Destination $(deploymentBackupFolder)
                Move-Item -Path $(tempFolder)\ -Destination $(deploymentFolder)
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Update IIS Rewrite Rules"
            condition: false # disabled until further testing and evaluation
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                $webConfigPath = "$(webConfigPath)"
                [xml]$webConfigXml = Get-Content $webConfigPath -Raw

                # build out XML nodes if they do not exist
                $rulesNode = $webConfigXml.configuration.location.'system.webServer'.rewrite.rules
                if (-not $rulesNode){
                    $rewriteNode = $webConfigXml.configuration.location.'system.webServer'.rewrite
                    if (-not $rewriteNode) {
                        $systemWebServerNode = $webConfigXml.configuration.location.'system.webServer'
                        $rewriteNode = $webConfigXml.CreateElement("rewrite")
                        $systemWebServerNode.AppendChild($rewriteNode) | Out-Null
                    }
                    $rulesNode = $webConfigXml.CreateElement("rules")
                    $rewriteNode.AppendChild($rulesNode) | Out-Null
                }

                # Add HTTP rule
                $httpRule = $webConfigXml.CreateElement("rule")
                $httpRule.SetAttribute('name', 'Forward HTTP')
                $httpRule.SetAttribute('stopProcessing', 'true')
                $httpAction = $webConfigXml.CreateElement('action')
                $httpAction.SetAttribute('type', 'Rewrite')
                $httpAction.SetAttribute('url', "$(forwardedHttpUrl)")
                $httpRule.AppendChild($httpAction)
                $rulesNode.AppendChild($httpRule)

                # Add HTTPS rule
                $httpsRule = $webConfigXml.CreateElement('rule')
                $httpsRule.SetAttribute('name', 'Forward HTTPS')
                $httpsRule.SetAttribute('stopProcessing', 'true')
                $httpsAction = $webConfigXml.CreateElement('action')
                $httpsAction.SetAttribute('type', 'Rewrite')
                $httpsAction.SetAttribute('url', "$(forwardedHttpsUrl)")
                $httpsRule.AppendChild($httpsAction)
                $rulesNode.AppendChild($httpsRule)
                $webConfigXml.Save($webConfigPath)
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Create New Windows Service And Start"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                Write-Host "Creating service $(serviceName)..."
                sc.exe create $(serviceName) binPath= "$(executablePath)" start= auto obj= $(serviceAccountName) password= "$(serviceAccountPassword)"
                sc.exe description $(serviceName) "$(serviceDescription)"
                Start-Service -Name $(serviceName)
              CommunicationProtocol: "Http"