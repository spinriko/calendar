# Azure Pipeline for PTO Track

trigger:
  branches:
    include:
      - main

# pr:
#   branches:
#     include:
#       - main

variables:
  - name: "dotnetVersion"
    value: "9.0.100"

  - name: "efToolVersion"
    value: "9.0.*"

  - name: "nodeVersion"
    value: "20.x"

  - name: "typescriptPath"
    value: 'C:\admin\typescript-5.9.3.tgz'

  - name: "esbuildPath"
    value: 'C:\admin\esbuild-0.27.1.tgz'

  - name: "solutionPath"
    value: "**/pto.track.sln"

  - name: "projectPath"
    value: "**/pto.track.csproj"

  - name: "appName"
    value: "pto.track"

  - name: "tempFolder"
    value: 'c:\self-contained_apps\$(appName)_temp'

  - name: "deploymentFolder"
    value: 'c:\self-contained_apps\$(appName)\'

  - name: "deploymentBackupFolder"
    value: 'c:\self-contained_apps\$(appName)_backup\'

  - name: "executablePath"
    value: '$(deploymentFolder)$(appName).exe'

  - name: "serviceName"
    value: "PTO_Track_Service"

  - name: "appPoolName"
    value: "pto-track"

  - name: "serviceDescription"
    value: "PTO Track .NET Core Web Application"

  - name: "webConfigPath"
    value: 'c:\self-contained_apps\$(appName)\web.config'

  - name: "forwardedHttpUrl"
    value: "http://localhost:5139"

  - name: "forwardedHttpsUrl"
    value: "https://localhost:7241"

  # additional variables are pulled from the UI

pool:
  name: DVO

stages:
  - stage: Build
    displayName: "Build Solution"
    jobs:
      - job: Build

        steps:
          - checkout: self
            persistCredentials: true
            fetchDepth: 0
            fetchTags: true

          - powershell: |
              git config user.email "devops@example.com"
              git config user.name "Azure DevOps"
              
              # Check if current commit already has a tag (manual override)
              $currentTag = git tag --points-at HEAD
              if ($currentTag) {
                Write-Host "##[section]Manual tag detected: $currentTag. Skipping auto-tag."
                exit 0
              }
              
              # Get the latest version tag
              $ErrorActionPreference = 'Continue'
              $lastTag = & git describe --tags --abbrev=0 --match "v*.*.*" 2>&1
              $ErrorActionPreference = 'Stop'
              
              if ($LASTEXITCODE -ne 0 -or -not $lastTag) {
                Write-Host "##[warning]No version tags found. Creating initial tag v0.1.0"
                $newTag = "v0.1.0"
              } else {
                Write-Host "##[section]Last tag: $lastTag"
                
                # Parse version (v1.2.3 -> 1.2.3)
                $version = $lastTag -replace '^v', ''
                $parts = $version -split '\.'
                $major = [int]$parts[0]
                $minor = [int]$parts[1]
                $patch = [int]$parts[2]
                
                # Increment patch
                $patch++
                $newTag = "v$major.$minor.$patch"
              }
              
              Write-Host "##[section]Creating and pushing tag: $newTag"
              git tag -a $newTag -m "Auto-increment patch version"
              git push origin $newTag
              
              Write-Host "##vso[task.setvariable variable=VersionTag]$newTag"

              # Generate version badge SVG in repo (docs/badges/version.svg)
              $badgeDir = Join-Path $(Build.SourcesDirectory) "docs/badges"
              if (-not (Test-Path $badgeDir)) { New-Item -ItemType Directory -Path $badgeDir -Force | Out-Null }
              $badgePath = Join-Path $badgeDir "version.svg"
              $svg = @"
              <?xml version="1.0" encoding="UTF-8"?>
              <svg xmlns="http://www.w3.org/2000/svg" width="130" height="20" role="img" aria-label="version: $newTag">
                <linearGradient id="s" x2="0" y2="100%">
                  <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
                  <stop offset="1" stop-opacity=".1"/>
                </linearGradient>
                <mask id="m"><rect width="130" height="20" rx="3" fill="#fff"/></mask>
                <g mask="url(#m)">
                  <rect width="60" height="20" fill="#555"/>
                  <rect x="60" width="70" height="20" fill="#007ec6"/>
                  <rect width="130" height="20" fill="url(#s)"/>
                </g>
                <g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" font-size="11">
                  <text x="30" y="15">version</text>
                  <text x="94" y="15">$newTag</text>
                </g>
              </svg>
              "@
              Set-Content -Path $badgePath -Value $svg -Encoding UTF8

              # Commit and push the updated badge to main (skip CI)
              try {
                git add $badgePath
                $staged = git diff --name-only --cached
                if ($staged) {
                  $msg = "chore(badges): update version badge to $newTag [skip ci]"
                  git commit -m $msg
                  git push origin HEAD:main
                  Write-Host "##[section]Pushed updated version badge to main"
                } else {
                  Write-Host "##[section]No changes to version badge detected; skipping commit"
                }
              } catch {
                Write-Warning "Failed to commit/push version badge: $($_.Exception.Message)"
              }

              # Also generate a PNG badge for Azure DevOps Server markdown rendering
              try {
                Add-Type -AssemblyName System.Drawing
                $width = 130; $height = 20
                $bmp = New-Object System.Drawing.Bitmap($width, $height)
                $gfx = [System.Drawing.Graphics]::FromImage($bmp)
                $gfx.SmoothingMode = [System.Drawing.Drawing2D.SmoothingMode]::AntiAlias
                $leftBrush = New-Object System.Drawing.SolidBrush([System.Drawing.Color]::FromArgb(0x55,0x55,0x55)) # #555
                $rightBrush = New-Object System.Drawing.SolidBrush([System.Drawing.Color]::FromArgb(0x00,0x7e,0xc6)) # #007ec6
                $overlay = New-Object System.Drawing.SolidBrush([System.Drawing.Color]::FromArgb(26,0,0,0))
                $gfx.FillRectangle($leftBrush, 0, 0, 60, $height)
                $gfx.FillRectangle($rightBrush, 60, 0, ($width - 60), $height)
                # light gradient overlay approximation omitted for simplicity
                $font = New-Object System.Drawing.Font('Verdana', 9, [System.Drawing.FontStyle]::Regular, [System.Drawing.GraphicsUnit]::Pixel)
                $white = New-Object System.Drawing.SolidBrush([System.Drawing.Color]::White)
                $format = New-Object System.Drawing.StringFormat
                $format.Alignment = [System.Drawing.StringAlignment]::Center
                $format.LineAlignment = [System.Drawing.StringAlignment]::Center
                $gfx.TextRenderingHint = [System.Drawing.Text.TextRenderingHint]::ClearTypeGridFit
                $gfx.DrawString('version', $font, $white, (New-Object System.Drawing.RectangleF(0,0,60,$height)), $format)
                $gfx.DrawString($newTag, $font, $white, (New-Object System.Drawing.RectangleF(60,0,($width - 60),$height)), $format)
                $pngPath = Join-Path $badgeDir 'version.png'
                $bmp.Save($pngPath, [System.Drawing.Imaging.ImageFormat]::Png)
                $gfx.Dispose(); $bmp.Dispose(); $font.Dispose(); $white.Dispose(); $leftBrush.Dispose(); $rightBrush.Dispose(); $overlay.Dispose()
                git add $pngPath
                $stagedPng = git diff --name-only --cached
                if ($stagedPng) {
                  $msg2 = "chore(badges): update PNG version badge to $newTag [skip ci]"
                  git commit -m $msg2
                  git push origin HEAD:main
                  Write-Host "##[section]Pushed updated PNG version badge to main"
                } else {
                  Write-Host "##[section]No changes to PNG version badge detected; skipping commit"
                }
              } catch {
                Write-Warning "Failed to generate/commit PNG badge: $($_.Exception.Message)"
              }
            displayName: "Auto-increment version tag"
            condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.SourceBranch'], 'refs/heads/main'))

          - task: UseDotNet@2
            displayName: "Ensure .NET SDK 9.0 Installed"
            condition: false
            inputs:
              packageType: "sdk"
              useGlobalJson: true
              includePreviewVersions: false
              performMultiLevelLookup: true # checks for local installs

          - task: DotNetCoreCLI@2
            displayName: "Ensure dotnet-ef is Installed"
            condition: false
            inputs:
              command: "custom"
              custom: "tool"
              arguments: install --global dotnet-ef --version $(efToolVersion)

          - script: node --version
            displayName: "Check Node.js on agent"

          

          - script: npm ci --prefix pto.track
            displayName: "Install frontend dependencies (pto.track)"

          - script: npm run build:js --prefix pto.track
            displayName: "Build frontend assets (pto.track)"

          - task: DotNetCoreCLI@2
            displayName: "Restore NuGet Packages"
            inputs:
              command: "restore"
              projects: "$(solutionPath)"

          - task: DotNetCoreCLI@2
            displayName: "Build Project"
            inputs:
              command: "build"
              projects: "$(solutionPath)"
              arguments: "--configuration Release --no-restore"

  - stage: Test
    displayName: "Run Tests and Coverage"
    dependsOn: Build
    jobs:
      - job: Test
        steps:
          - checkout: self

          - powershell: |
              New-Item -ItemType Directory -Force "$(Build.SourcesDirectory)/TestResults/coverage" | Out-Null
            displayName: "Ensure coverage output directory"

          - script: node --version
            displayName: "Check Node.js on agent (Test Job)"          

          - script: npm --version
            displayName: "Check npm on agent (Test Job)"
            
          # Run JavaScript tests (Jest). Puppeteer Chromium download is skipped
          # to avoid headless/browser installs on restricted build agents.
          # add these back in after downgrading npm
          #- script: |
          #    npm ci --prefix pto.track.tests.js
          #  displayName: "Install JS test dependencies (pto.track.tests.js)"
          #  env:
          #    PUPPETEER_SKIP_DOWNLOAD: true

          #- script: |
          #    npm test --prefix pto.track.tests.js --silent
          #  displayName: "Run JavaScript tests (pto.track.tests.js)"
          #  env:
          #    PUPPETEER_SKIP_DOWNLOAD: true

          - task: DotNetCoreCLI@2
            displayName: "Test Services"
            inputs:
              testRunTitle: "Test Services"
              command: "test"
              projects: "**/pto.track.services.tests.csproj"
              arguments: '--configuration Release --logger "trx;LogFileName=services_tests.trx" --results-directory "$(Build.SourcesDirectory)\TestResults\services" --collect:"XPlat Code Coverage"'
              publishTestResults: false # handled in arguments

          - task: DotNetCoreCLI@2
            displayName: "Test App"
            inputs:
              testRunTitle: "Test App"
              command: "test"
              projects: "**/pto.track.tests.csproj"
              arguments: '--configuration Release --logger "trx;LogFileName=app_tests.trx" --results-directory "$(Build.SourcesDirectory)\TestResults\app" --collect:"XPlat Code Coverage"'
              publishTestResults: false # handled in arguments

          - task: DotNetCoreCLI@2
            displayName: "Test Data"
            inputs:
              testRunTitle: "Test Data"
              command: "test"
              projects: "**/pto.track.data.tests.csproj"
              arguments: '--configuration Release --logger "trx;LogFileName=data_tests.trx" --results-directory "$(Build.SourcesDirectory)\TestResults\data" --collect:"XPlat Code Coverage"'
              publishTestResults: false # handled in arguments

          - powershell: |
              $env:PATH += ";$env:USERPROFILE\.dotnet\tools"
              if (-not (Get-Command reportgenerator -ErrorAction SilentlyContinue)) {
                dotnet tool install --global dotnet-reportgenerator-globaltool
              }
              reportgenerator "-reports:$(Build.SourcesDirectory)/TestResults/**/coverage.cobertura.xml" "-targetdir:$(Build.SourcesDirectory)/TestResults/coverage-merged" "-reporttypes:Cobertura"
            displayName: "Merge coverage with ReportGenerator"
          - task: PublishTestResults@2
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "**/TestResults/**/*.trx"
              mergeTestResults: true
              testRunTitle: "Dotnet Tests"

          - task: PublishCodeCoverageResults@1
            inputs:
              codeCoverageTool: "Cobertura"
              summaryFileLocation: "$(Build.SourcesDirectory)/TestResults/coverage-merged/Cobertura.xml"
              failIfCoverageEmpty: true

          - task: PublishBuildArtifacts@1
            condition: false
            inputs:
              pathToPublish: "$(System.DefaultWorkingDirectory)/pto.track.tests.js/save-results.html"
              artifactName: "JavaScriptTestReport"
              publishLocation: "Container"

  - stage: Analyze
    displayName: "Run Analyzers and Metrics"
    dependsOn: Test
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: Analyze
        steps:
          - task: PowerShell@2
            displayName: "Run Roslyn Analyzers"
            inputs:
              filePath: "./scripts/run-analyzers.ps1"
              arguments: "-Execute"

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(System.DefaultWorkingDirectory)/artifacts/analyzers"
              artifactName: "analyzers"
              publishLocation: "Container"

          - task: DotNetCoreCLI@2
            displayName: "Build metrics-runner (console)"
            inputs:
              command: "build"
              projects: "**/metrics-runner.csproj"
              arguments: "--configuration Release"

          - task: DotNetCoreCLI@2
            displayName: "Run metrics-runner (console)"
            inputs:
              command: "run"
              projects: "**/metrics-runner"
              arguments: "-- '$(Build.SourcesDirectory)'"

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(System.DefaultWorkingDirectory)/artifacts/metrics"
              artifactName: "metrics"
              publishLocation: "Container"

  - stage: Publish
    displayName: "Publish Standalone App"
    dependsOn: Analyze
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: Publish
        steps:
          - checkout: none
          - download: current

          - task: DotNetCoreCLI@2
            displayName: "Generate Self-Contained App"
            inputs:
              command: "publish"
              publishWebProjects: false
              projects: "$(projectPath)"
              arguments: >
                --configuration Release
                --runtime win-x64
                --self-contained true
                --output $(Build.ArtifactStagingDirectory)/publish

          - task: PublishBuildArtifacts@1
            displayName: "Publish Build Artifact"
            inputs:
              PathtoPublish: "$(Build.ArtifactStagingDirectory)/publish"
              ArtifactName: "build_artifact"

  - stage: DeployDev
    displayName: "Deploy to Development Server"
    dependsOn: Publish
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      - group: "DevOps Automation Accounts"
      - group: "ASBDotNetWebApps-DEV"
    jobs:
      - job: Deploy

        steps:
          - checkout: none
          - download: current

          - task: PowerShellOnTargetMachines@3
            displayName: "Check IIS Installation"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                $iisFeature = Get-WindowsFeature -Name Web-Server
                if (-not $iisFeature.Installed) {
                    Write-Error "IIS (Web-Server) is not installed. Deployment cannot continue."
                    exit 1
                }
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Stop and remove current service"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |

                if (Get-Service -Name $(serviceName)) {
                  Write-Host "Service $(serviceName) exists. Stopping and removing..."
                  Stop-Service -Name $(serviceName) -Force -ErrorAction SilentlyContinue
                  sc.exe delete $(serviceName)                
                  Write-Host "Service $(serviceName) was stopped and removed."
                } else {
                  Write-Host "Service $(serviceName) did not exist OR there was an error getting the service."
                }
              CommunicationProtocol: "Http"

          - task: WindowsMachineFileCopy@2
            displayName: "Copy Build Artifact to Web Server"
            inputs:
              SourcePath: "$(Pipeline.Workspace)/build_artifact/pto.track.zip"
              MachineNames: "$(webServerDev)"
              AdminUserName: "$(automationAcctName)"
              AdminPassword: "$(automationAcctPass)"
              TargetPath: '\\$(webServerDev)\$(tempFolder)\'
              CleanTargetBeforeCopy: true

          - task: PowerShellOnTargetMachines@3
            displayName: "Extract Artifact"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                $zip = Get-ChildItem -Path $(tempFolder)\ -Recurse | where {$_.Name -match ".zip"}
                $zip | Expand-Archive -DestinationPath $(tempFolder)\
                $zip | Remove-Item
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Set ASPNETCORE_ENVIRONMENT=$(pto-track-env) (Machine)"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                Write-Host "Setting ASPNETCORE_ENVIRONMENT=$(pto-track-env) at Machine scope"
                [Environment]::SetEnvironmentVariable("ASPNETCORE_ENVIRONMENT", "$(pto-track-env)", "Machine")
                $envVal = [Environment]::GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT", "Machine")
                Write-Host "ASPNETCORE_ENVIRONMENT (Machine) now: $envVal"
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Set ConnectionStrings__PtoTrackDbContext from variable group"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                Write-Host "Setting ConnectionStrings__PtoTrackDbContext at Machine scope"
                if (-not $env:sqlConnectionString -and -not "$(sqlConnectionString)") {
                  Write-Error "sqlConnectionString variable is not defined"
                }
                $conn = "$(sqlConnectionString)"
                if (-not $conn) { $conn = $env:sqlConnectionString }
                [Environment]::SetEnvironmentVariable("ConnectionStrings__PtoTrackDbContext", $conn, "Machine")
                $current = [Environment]::GetEnvironmentVariable("ConnectionStrings__PtoTrackDbContext", "Machine")
                if ($current) {
                  Write-Host "ConnectionStrings__PtoTrackDbContext set. Length: $($current.Length)"
                } else {
                  Write-Error "Failed to set ConnectionStrings__PtoTrackDbContext"
                }
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Replace Previous App Files/Folders"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                if (Test-Path $(deploymentBackupFolder)){
                  Remove-Item $(deploymentBackupFolder) -Recurse -Force
                }
                Move-Item -Path $(deploymentFolder) -Destination $(deploymentBackupFolder)
                Move-Item -Path $(tempFolder)\ -Destination $(deploymentFolder)
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Update IIS Rewrite Rules"
            condition: false # disabled until further testing and evaluation
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                $webConfigPath = "$(webConfigPath)"
                [xml]$webConfigXml = Get-Content $webConfigPath -Raw

                # build out XML nodes if they do not exist
                $rulesNode = $webConfigXml.configuration.location.'system.webServer'.rewrite.rules
                if (-not $rulesNode){
                    $rewriteNode = $webConfigXml.configuration.location.'system.webServer'.rewrite
                    if (-not $rewriteNode) {
                        $systemWebServerNode = $webConfigXml.configuration.location.'system.webServer'
                        $rewriteNode = $webConfigXml.CreateElement("rewrite")
                        $systemWebServerNode.AppendChild($rewriteNode) | Out-Null
                    }
                    $rulesNode = $webConfigXml.CreateElement("rules")
                    $rewriteNode.AppendChild($rulesNode) | Out-Null
                }

                # Add HTTP rule
                $httpRule = $webConfigXml.CreateElement("rule")
                $httpRule.SetAttribute('name', 'Forward HTTP')
                $httpRule.SetAttribute('stopProcessing', 'true')
                $httpAction = $webConfigXml.CreateElement('action')
                $httpAction.SetAttribute('type', 'Rewrite')
                $httpAction.SetAttribute('url', "$(forwardedHttpUrl)")
                $httpRule.AppendChild($httpAction)
                $rulesNode.AppendChild($httpRule)

                # Add HTTPS rule
                $httpsRule = $webConfigXml.CreateElement('rule')
                $httpsRule.SetAttribute('name', 'Forward HTTPS')
                $httpsRule.SetAttribute('stopProcessing', 'true')
                $httpsAction = $webConfigXml.CreateElement('action')
                $httpsAction.SetAttribute('type', 'Rewrite')
                $httpsAction.SetAttribute('url', "$(forwardedHttpsUrl)")
                $httpsRule.AppendChild($httpsAction)
                $rulesNode.AppendChild($httpsRule)
                $webConfigXml.Save($webConfigPath)
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Create New Windows Service And Start"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                Write-Host "Creating service $(serviceName)..."
                sc.exe create $(serviceName) binPath= "$(executablePath)" start= auto obj= $(serviceAccountName) password= "$(serviceAccountPassword)"
                sc.exe description $(serviceName) "$(serviceDescription)"
                Start-Service -Name $(serviceName)
              CommunicationProtocol: "Http"