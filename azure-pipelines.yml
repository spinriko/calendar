# Azure Pipeline for PTO Track

trigger:
  branches:
    include:
      - BuildOnly
      - WithoutEnvironment

variables:
  - group: "DevOps Automation Accounts"

  - name: "dotnetVersion"
    value: "9.0.100"

  - name: "efToolVersion"
    value: "9.0.*"

  - name: "nodeVersion"
    value: "20.x"

  - name: "typescriptPath"
    value: 'C:\admin\typescript-5.9.3.tgz'

  - name: "esbuildPath"
    value: 'C:\admin\esbuild-0.27.1.tgz'

  - name: "solutionPath"
    value: "**/pto.track.sln"

  - name: "projectPath"
    value: "**/pto.track.csproj"

  - name: "appName"
    value: "pto.track"

  - name: "tempFolder"
    value: 'c:\self-contained_apps\$(appName)_temp'

  - name: "deploymentFolder"
    value: 'c:\self-contained_apps\$(appName)\'

  - name: "deploymentBackupFolder"
    value: 'c:\self-contained_apps\$(appName)_backup\'

  - name: "executablePath"
    value: '$(deploymentFolder)\$(appName).exe'

  - name: "serviceName"
    value: "PTO_Track_Service"

  - name: "appPoolName"
    value: "pto-track"

  - name: "serviceDescription"
    value: "PTO Track .NET Core Web Application"

  - name: "webConfigPath"
    value: 'c:\self-contained_apps\$(appName)\web.config'

  - name: "forwardedHttpUrl"
    value: "http://localhost:5139"

  - name: "forwardedHttpsUrl"
    value: "https://localhost:7241"

  # additional variables are pulled from the UI

pool:
  name: DVO

stages:
  - stage: Build
    displayName: "Build Solution"
    jobs:
      - job: Build

        steps:
          - task: UseDotNet@2
            displayName: "Ensure .NET SDK 9.0 Installed"
            condition: false
            inputs:
              packageType: "sdk"
              version: $(dotnetVersion)
              useGlobalJson: false
              includePreviewVersions: false
              performMultiLevelLookup: true # checks for local installs

          - task: DotNetCoreCLI@2
            displayName: "Ensure dotnet-ef is Installed"
            condition: false
            inputs:
              command: "custom"
              custom: "tool"
              arguments: install --global dotnet-ef --version $(efToolVersion)

          - task: NodeTool@0
            displayName: "Ensure Node.js is Installed"
            inputs:
              versionSpec: $(dotnetVersion)
            condition: false

          - script: npm install --global $(typescriptPath)
            displayName: "Ensure typescript is Installed"
            condition: false

          - script: npm install --global $(esbuildPath)
            displayName: "Ensure esbuild is Installed"
            condition: false

          - task: DotNetCoreCLI@2
            displayName: "Restore NuGet Packages"
            inputs:
              command: "restore"
              projects: "$(solutionPath)"

          - task: DotNetCoreCLI@2
            displayName: "Build Project"
            inputs:
              command: "build"
              projects: "$(projectPath)"
              arguments: "--configuration Release --no-restore"

  - stage: Test
    displayName: "Run Tests and Coverage"
    dependsOn: Build
    jobs:
      - job: Test
        steps:
          - checkout: none

          - task: DotNetCoreCLI@2
            displayName: "Test Services"
            inputs:
              testRunTitle: "Test Services"
              command: "test"
              projects: "**/pto.track.services.tests.csproj"
              arguments: '--configuration Release --logger "trx;LogFileName=services_tests.trx" /p:CollectCoverage=true --results-directory "$(Build.SourcesDirectory)\TestResults\services"'
              publishTestResults: false # handled in arguments

          - task: DotNetCoreCLI@2
            displayName: "Test App"
            inputs:
              testRunTitle: "Test App"
              command: "test"
              projects: "**/pto.track.tests.csproj"
              arguments: '--configuration Release --logger "trx;LogFileName=app_tests.trx" /p:CollectCoverage=true --results-directory "$(Build.SourcesDirectory)\TestResults\app"'
              publishTestResults: false # handled in arguments

          - task: DotNetCoreCLI@2
            displayName: "Test Data"
            inputs:
              testRunTitle: "Test Data"
              command: "test"
              projects: "**/pto.track.data.tests.csproj"
              arguments: '--configuration Release --logger "trx;LogFileName=data_tests.trx" /p:CollectCoverage=true --results-directory "$(Build.SourcesDirectory)\TestResults\data"'
              publishTestResults: false # handled in arguments

          - task: PowerShell@2
            displayName: "Run JavaScript Tests (QUinit/Puppeteer)"
            condition: false
            inputs:
              filePath: "./pto.track.tests.js/run-headless.ps1"
              pwsh: true

          - task: PublishTestResults@2
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "**/TestResults/**/*.trx"
              mergeTestResults: true
              testRunTitle: "Dotnet Tests"

          - task: PublishCodeCoverageResults@1
            inputs:
              codeCoverageTool: "Cobertura"
              summaryFileLocation: "$(Build.SourcesDirectory)/**/coverage.cobertura.xml"
              reportDirectory: "$(Build.SourcesDirectory)/coverage-report"

          - task: PublishBuildArtifacts@1
            condition: false
            inputs:
              pathToPublish: "$(System.DefaultWorkingDirectory)/pto.track.tests.js/save-results.html"
              artifactName: "JavaScriptTestReport"
              publishLocation: "Container"

  - stage: Analyze
    displayName: "Run Analyzers and Metrics"
    dependsOn: Test
    jobs:
      - job: Analyze
        steps:
          - task: PowerShell@2
            displayName: "Run Roslyn Analyzers"
            inputs:
              filePath: "./scripts/run-analyzers.ps1"
              arguments: "-Execute"

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(System.DefaultWorkingDirectory)/artifacts/analyzers"
              artifactName: "analyzers"
              publishLocation: "Container"

          - task: DotNetCoreCLI@2
            displayName: "Build metrics-runner (console)"
            inputs:
              command: "build"
              projects: "**/metrics-runner.csproj"
              arguments: "--configuration Release"

          - task: DotNetCoreCLI@2
            displayName: "Run metrics-runner (console)"
            inputs:
              command: "run"
              projects: "**/metrics-runner"
              arguments: "-- '$(Build.SourcesDirectory)'"

          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: "$(System.DefaultWorkingDirectory)/artifacts/metrics"
              artifactName: "metrics"
              publishLocation: "Container"

  - stage: Publish
    displayName: "Publish Standalone App"
    dependsOn: Analyze
    jobs:
      - job: Publish
        steps:
          - checkout: none
          - download: current

          - task: DotNetCoreCLI@2
            displayName: "Generate Self-Contained App"
            inputs:
              command: "publish"
              publishWebProjects: false
              projects: "$(projectPath)"
              arguments: >
                --configuration Release
                --runtime win-x64
                --self-contained true
                /p:PublishSingleFile=true
                /p:IncludesNativeLibrariesForSelfExtract=true
                /p:PublishedTrimmed=false
                --output $(Build.ArtifactStagingDirectory)/publish

          - task: PublishBuildArtifacts@1
            displayName: "Publish Build Artifact"
            inputs:
              PathtoPublish: "$(Build.ArtifactStagingDirectory)/publish"
              ArtifactName: "build_artifact"

  - stage: DeployDev
    displayName: "Deploy to Development Server"
    dependsOn: Publish
    jobs:
      - job: Deploy
        variables:
          environment: "Development"
          sqlConnString: "Server=$(sqlServerDev),$(sqlServerPort);Database=$(dbNameDev);Integrated Security=True;TrustServerCertificate=True;"

        steps:
          - checkout: none
          - download: current

          - task: PowerShellOnTargetMachines@3
            displayName: "Check IIS Installation"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                $iisFeature = Get-WindowsFeature -Name Web-Server
                if (-not $iisFeature.Installed) {
                    Write-Error "IIS (Web-Server) is not installed. Deployment cannot continue."
                    exit 1
                }
              CommunicationProtocol: "Http"

          - task: WindowsMachineFileCopy@2
            displayName: "Copy Build Artifact to Web Server"
            inputs:
              SourcePath: "$(Pipeline.Workspace)/build_artifact/pto.track.zip"
              MachineNames: "$(webServerDev)"
              AdminUserName: "$(automationAcctName)"
              AdminPassword: "$(automationAcctPass)"
              TargetPath: '\\$(webServerDev)\$(tempFolder)\'
              CleanTargetBeforeCopy: true

          - task: PowerShellOnTargetMachines@3
            displayName: "Extract Artifact"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                $zip = Get-ChildItem -Path $(tempFolder)\ -Recurse | where {$_.Name -match ".zip"}
                $zip | Expand-Archive -DestinationPath $(tempFolder)\
                $zip | Remove-Item
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Apply appsettings.$(Environment).json"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                if (Test-Path $(tempFolder)\appsettings.$(Environment).json) {
                  Remove-Item $(tempFolder)\appsettings.$(Environment).json -Force
                  Copy-Item -Path $(tempFolder)\appsettings.json -Destination $(tempFolder)\appsettings.$(Environment).json
                }
                $content = Get-Content -Path $(tempFolder)\appsettings.$(Environment).json -Raw
                $content -replace "user-secrets", "$(sqlConnString)" | Set-Content $(tempFolder)\appsettings.$(Environment).json
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Create Windows Service"
            condition: false # temporarily disabled in favor of IIS app pool
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                # TODO check if service account has 'Log On As a Service' rights

                if (Get-Service -Name $(serviceName) -ErrorAction SilentlyContinue) {
                  Write-Host "Service $(serviceName) exists. Stopping and removing..."
                  Stop-Service -Name $(serviceName) -Force
                  sc.exe delete $(serviceName)
                }
                Write-Host "Creating service $(serviceName)..."
                sc.exe create $(serviceName) binPath= "$(executablePath)" start= auto obj= $(serviceAccountName) password= "$(serviceAccountPassword)"
                sc.exe description $(serviceName) "$(serviceDescription)"
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Stop Web AppPool"
            condition: true # temporarily enabled
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                if ((Get-WebAppPoolState -Name "$(appPoolName)").value -ne 'stopped'){
                  Stop-WebAppPool -Name "$(appPoolName)"
                }
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Replace Previous App Files/Folders"
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                if (Test-Path $(deploymentBackupFolder)){
                  Remove-Item $(deploymentBackupFolder) -Recurse -Force
                }
                Move-Item -Path $(deploymentFolder) -Destination $(deploymentBackupFolder)
                Move-Item -Path $(tempFolder)\ -Destination $(deploymentFolder)
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Start Web App Service"
            condition: false # temporarily disabled in favor of IIS app pool
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                Start-Service $(serviceName)
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Start Web AppPool"
            condition: true # temporarily enabled
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                Start-WebAppPool -Name "$(appPoolName)"
              CommunicationProtocol: "Http"

          - task: PowerShellOnTargetMachines@3
            displayName: "Update IIS Rewrite Rules"
            condition: false # disabled until further testing and evaluation
            inputs:
              Machines: "$(webServerDev)"
              UserName: "$(automationAcctName)"
              UserPassword: "$(automationAcctPass)"
              InlineScript: |
                $webConfigPath = "$(webConfigPath)"
                [xml]$webConfigXml = Get-Content $webConfigPath -Raw

                # build out XML nodes if they do not exist
                $rulesNode = $webConfigXml.configuration.location.'system.webServer'.rewrite.rules
                if (-not $rulesNode){
                    $rewriteNode = $webConfigXml.configuration.location.'system.webServer'.rewrite
                    if (-not $rewriteNode) {
                        $systemWebServerNode = $webConfigXml.configuration.location.'system.webServer'
                        $rewriteNode = $webConfigXml.CreateElement("rewrite")
                        $systemWebServerNode.AppendChild($rewriteNode) | Out-Null
                    }
                    $rulesNode = $webConfigXml.CreateElement("rules")
                    $rewriteNode.AppendChild($rulesNode) | Out-Null
                }

                # Add HTTP rule
                $httpRule = $webConfigXml.CreateElement("rule")
                $httpRule.SetAttribute('name', 'Forward HTTP')
                $httpRule.SetAttribute('stopProcessing', 'true')
                $httpAction = $webConfigXml.CreateElement('action')
                $httpAction.SetAttribute('type', 'Rewrite')
                $httpAction.SetAttribute('url', "$(forwardedHttpUrl)")
                $httpRule.AppendChild($httpAction)
                $rulesNode.AppendChild($httpRule)

                # Add HTTPS rule
                $httpsRule = $webConfigXml.CreateElement('rule')
                $httpsRule.SetAttribute('name', 'Forward HTTPS')
                $httpsRule.SetAttribute('stopProcessing', 'true')
                $httpsAction = $webConfigXml.CreateElement('action')
                $httpsAction.SetAttribute('type', 'Rewrite')
                $httpsAction.SetAttribute('url', "$(forwardedHttpsUrl)")
                $httpsRule.AppendChild($httpsAction)
                $rulesNode.AppendChild($httpsRule)
                $webConfigXml.Save($webConfigPath)
              CommunicationProtocol: "Http"
