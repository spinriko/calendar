# Azure Pipeline for PTO Track

trigger:
  branches:
    include:
      - main

variables:
  serverName: 'YOUR_SERVER_NAME'
  deployFolder: 'c:\inet\pto.track'
  forwardedHttpUrl: 'http://localhost:5139'
  forwardedHttpsUrl: 'https://localhost:7241'
  rewritePath: 'c:\inet\pto.track\web.config'
  serviceName: 'PTO Track Service'
  serviceAccount: 'NT AUTHORITY\NetworkService' # Change as needed
  servicePassword: $(servicePassword) # Mark as secret in Azure DevOps
  serviceEnvVars: '' # Add environment variables as needed, e.g. "ASPNETCORE_ENVIRONMENT=Production;CUSTOM_VAR=value"

pool:
  name: Default

stages:

  - stage: Build
    displayName: 'Build Solution and Frontend'
    jobs:
      - job: Build
        steps:
          - powershell: |
              $sdk = dotnet --list-sdks
              if ($sdk -notmatch '9.0') {
                  Write-Host 'Required .NET SDK 9.0 is not installed. Attempting installation...'
                  Invoke-WebRequest -Uri "https://dotnet.microsoft.com/download/dotnet/thank-you/sdk-9.0.100-windows-x64-installer" -OutFile "dotnet-sdk-9.0.100-win-x64.exe"
                  Start-Process -FilePath "dotnet-sdk-9.0.100-win-x64.exe" -ArgumentList "/quiet" -Wait
                  Remove-Item "dotnet-sdk-9.0.100-win-x64.exe"
                  $sdk = dotnet --list-sdks
                  if ($sdk -notmatch '9.0') {
                      Write-Error 'Failed to install .NET SDK 9.0.'
                      exit 1
                  }
              }
            displayName: 'Ensure .NET SDK 9.0 Installed'
            failOnStderr: true
          - powershell: |
              $efTool = dotnet tool list -g | Select-String 'dotnet-ef'
              if (-not $efTool) {
                  Write-Host 'dotnet-ef tool is not installed globally. Attempting installation...'
                  dotnet tool install -g dotnet-ef
                  $efTool = dotnet tool list -g | Select-String 'dotnet-ef'
                  if (-not $efTool) {
                      Write-Error 'Failed to install dotnet-ef tool.'
                      exit 1
                  }
              }
            displayName: 'Ensure dotnet-ef Tool Installed'
            failOnStderr: true
          - script: dotnet restore
            displayName: 'Restore NuGet Packages'
          - script: dotnet build pto.track/pto.track.csproj --configuration Release
            displayName: 'Build Project'
          - task: NodeTool@0
            inputs:
              versionSpec: '20.x'
            displayName: 'Use Node.js 20.x'
          - script: npm install --prefix pto.track && npm run build --prefix pto.track
            displayName: 'Build Frontend Bundles (esbuild)'
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(System.DefaultWorkingDirectory)/pto.track/wwwroot/dist'
              artifactName: 'frontend-dist'
              publishLocation: 'Container'


  - stage: Test
    displayName: 'Run Tests and Coverage'
    dependsOn: Build
    jobs:
      - job: Test
        steps:
          - script: dotnet test pto.track.services.tests/pto.track.services.tests.csproj --logger "trx;LogFileName=services_tests.trx" /p:CollectCoverage=true --results-directory $(Build.SourcesDirectory)/TestResults/services
            displayName: 'Test Services'
          - script: dotnet test pto.track.tests/pto.track.tests.csproj --logger "trx;LogFileName=app_tests.trx" /p:CollectCoverage=true --results-directory $(Build.SourcesDirectory)/TestResults/app
            displayName: 'Test App'
          - script: dotnet test pto.track.data.tests/pto.track.data.tests.csproj --logger "trx;LogFileName=data_tests.trx" --results-directory $(Build.SourcesDirectory)/TestResults/data
            displayName: 'Test Data'
          - script: pwsh ./pto.track.tests.js/run-headless.ps1
            displayName: 'Run JavaScript Tests (QUnit/Puppeteer)'
          - task: PublishTestResults@2
            inputs:
              testResultsFormat: 'VSTest'
              testResultsFiles: '**/TestResults/**/*.trx'
              mergeTestResults: true
              testRunTitle: 'Dotnet Tests'
          - task: PublishCodeCoverageResults@1
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '$(Build.SourcesDirectory)/**/coverage.cobertura.xml'
              reportDirectory: '$(Build.SourcesDirectory)/coverage-report'
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(System.DefaultWorkingDirectory)/pto.track.tests.js/save-results.html'
              artifactName: 'JavaScriptTestReport'
              publishLocation: 'Container'
  - stage: Analyze
    displayName: 'Run Analyzers and Metrics'
    dependsOn: Test
    jobs:
      - job: Analyze
        steps:
          - script: pwsh ./scripts/run-analyzers.ps1 -Execute
            displayName: 'Run Roslyn Analyzers'
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(System.DefaultWorkingDirectory)/artifacts/analyzers'
              artifactName: 'analyzers'
              publishLocation: 'Container'
          - script: |
              dotnet build tools/metrics-runner/metrics-runner.csproj -c Release
              dotnet run --project tools/metrics-runner -- "$(Build.SourcesDirectory)"
            displayName: 'Run metrics-runner (console)'
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(System.DefaultWorkingDirectory)/artifacts/metrics'
              artifactName: 'metrics'
              publishLocation: 'Container'


  - stage: Publish
    displayName: 'Publish Standalone App'
    dependsOn: Analyze
    jobs:
      - job: Publish
        steps:
          - script: dotnet publish pto.track/pto.track.csproj -c Release -o $(deployFolder) --self-contained -r win-x64
            displayName: 'Publish Standalone Application'
          - task: PublishBuildArtifacts@1
            inputs:
              pathToPublish: '$(deployFolder)'
              artifactName: 'app-publish'
              publishLocation: 'Container'

  - stage: Deploy
    displayName: 'Deploy to IIS Server'
    dependsOn: Publish
    jobs:
      - job: Deploy
        steps:
            - powershell: |
              $exePath = Join-Path "$(deployFolder)" "pto.track.exe"
              $svcName = "$(serviceName)"
              $svcAccount = "$(serviceAccount)"
              $svcPassword = "$(servicePassword)"
              $envVars = "$(serviceEnvVars)"
              if (Get-Service -Name $svcName -ErrorAction SilentlyContinue) {
                Write-Host "Service $svcName exists. Stopping and removing..."
                Stop-Service -Name $svcName -Force
                sc.exe delete "$svcName"
              }
              Write-Host "Creating service $svcName..."
              if ($svcAccount -ne 'NT AUTHORITY\NetworkService' -and $svcPassword -ne '') {
                $createCmd = "sc.exe create `"$svcName`" binPath= `"$exePath`" obj= `"$svcAccount`" password= `"$svcPassword`""
              } else {
                $createCmd = "sc.exe create `"$svcName`" binPath= `"$exePath`" obj= `"$svcAccount`""
              }
              Invoke-Expression $createCmd
              if ($envVars -ne '') {
                Write-Host "Setting environment variables for service..."
                $envVars.Split(';') | ForEach-Object {
                  $pair = $_.Split('=')
                  if ($pair.Length -eq 2) {
                    [Environment]::SetEnvironmentVariable($pair[0], $pair[1], 'Machine')
                  }
                }
              }
              Start-Service -Name $svcName
            displayName: 'Create and Start Windows Service'
            failOnStderr: true
          - powershell: |
              # Check for IIS installation
              $iisFeature = Get-WindowsFeature -Name Web-Server
              if (-not $iisFeature.Installed) {
                  Write-Error "IIS (Web-Server) is not installed. Deployment cannot continue."
                  exit 1
              }
            displayName: 'Check IIS Installation'
            failOnStderr: true
          - task: CopyFiles@2
            inputs:
              SourceFolder: '$(deployFolder)'
              Contents: '**'
              TargetFolder: '\\$(serverName)\$(deployFolder)'
          - powershell: |
              # Update IIS rewrite rules
              $webConfig = "$(rewritePath)"
              [xml]$config = Get-Content $webConfig
              $rules = $config.configuration.'system.webServer'.rewrite.rules
              # Remove existing rules (optional)
              $rules.Clear()
              # Add HTTP rule
              $httpRule = $rules.CreateElement('rule')
              $httpRule.SetAttribute('name', 'Forward HTTP')
              $httpRule.SetAttribute('stopProcessing', 'true')
              $httpAction = $httpRule.CreateElement('action')
              $httpAction.SetAttribute('type', 'Rewrite')
              $httpAction.SetAttribute('url', '$(forwardedHttpUrl)')
              $httpRule.AppendChild($httpAction)
              $rules.AppendChild($httpRule)
              # Add HTTPS rule
              $httpsRule = $rules.CreateElement('rule')
              $httpsRule.SetAttribute('name', 'Forward HTTPS')
              $httpsRule.SetAttribute('stopProcessing', 'true')
              $httpsAction = $httpsRule.CreateElement('action')
              $httpsAction.SetAttribute('type', 'Rewrite')
              $httpsAction.SetAttribute('url', '$(forwardedHttpsUrl)')
              $httpsRule.AppendChild($httpsAction)
              $rules.AppendChild($httpsRule)
              $config.Save($webConfig)
            displayName: 'Update IIS Rewrite Rules'
            failOnStderr: true
