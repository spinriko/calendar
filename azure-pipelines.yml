trigger:
  - main

pr:
  - main

variables:
  - group: "ASBDotNetWebApps-DEV"
  - group: "DevOps Automation Accounts"

  - name: buildConfiguration
    value: "Release"
  - name: runtime
    value: "win-x64"
  - name: solution
    value: "pto.track.sln"
  - name: webProject
    value: "pto.track/pto.track.csproj"
  - name: toolsProject
    value: "tools/metrics-runner/metrics-runner.csproj"

  - name: healthUrl
    value: "http://$(webServer)/health/live"
  - name: readyHealthUrl
    value: "http://$(webServer)/health/ready"

pool:
  name: DVO

stages:

  # =====================================================================
  # STAGE: BUILD
  # =====================================================================
  - stage: Build
    displayName: "Build, test, analyze"
    jobs:
      - job: BuildAndTest
        steps:
          - task: PowerShell@2
            displayName: "Ensure TestResults folder exists"
            inputs:
              pwsh: false
              targetType: inline
              script: |
                New-Item -ItemType Directory -Force -Path "$(Build.SourcesDirectory)/TestResults"

          - task: PowerShell@2
            displayName: "Build JS static assets"
            inputs:
              targetType: inline
              script: |
                $env:PATH = "$env:nodePath;$env:PATH"
                & $env:npmPath  --prefix "$(Build.SourcesDirectory)/pto.track" ci
                if ($LASTEXITCODE -ne 0) { throw "npm ci failed." }

                & $env:npmPath --prefix "$(Build.SourcesDirectory)/pto.track" run build:js
                if ($LASTEXITCODE -ne 0) { throw "npm run build:js failed." }
              workingDirectory: "$(Build.SourcesDirectory)/pto.track"
              pwsh: false

          - task: PublishBuildArtifacts@1
            displayName: "Publish JS static assets"
            inputs:
              PathtoPublish: "$(Build.SourcesDirectory)/pto.track/wwwroot/dist"
              ArtifactName: "wwwroot-dist"
              publishLocation: "Container"

          - task: PowerShell@2
            displayName: "Run JS tests"
            condition:  false # infosec block on downloading an npm that works
            inputs:
              targetType: inline
              script: |
                $env:PATH = "$env:nodePath;$env:PATH"
                npx -p npm@10 npm --prefix "$(Build.SourcesDirectory)/pto.track.tests.js" ci
                if ($LASTEXITCODE -ne 0) { throw "npm ci failed." }

                $env:PATH = "$env:nodePath;$env:PATH"
                npx -p npm@10 npm --prefix "$(Build.SourcesDirectory)/pto.track.tests.js" test
                if ($LASTEXITCODE -ne 0) { throw "npm test failed." }
              workingDirectory: "$(Build.SourcesDirectory)/pto.track"
              pwsh: false

          - task: PowerShell@2
            displayName: 'debug list sdks and runtimes'
            inputs:
              targetType: inline
              script: |
                Write-Host "List of installed sdks"
                & dotnet --list-sdks
                Write-Host "================"
                Write-Host "List of installed runtimes"
                & dotnet --list-runtimes
              pwsh: false

          - task: DotNetCoreCLI@2
            displayName: "Restore solution"
            inputs:
              command: restore
              projects: "$(solution)"

          - task: DotNetCoreCLI@2
            displayName: "Build solution"
            inputs:
              command: build
              projects: "$(solution)"
              arguments: "--configuration $(buildConfiguration)"

          - task: DotNetCoreCLI@2
            displayName: "Run .NET tests"
            inputs:
              command: test
              publishTestResults: false
              arguments: >
                --configuration $(buildConfiguration)
                --logger "trx;LogFileName=testresults.trx"
                --results-directory "$(Build.SourcesDirectory)/TestResults"
                /p:SkipNpm=true
                /p:CollectCoverage=true
                /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/coverage
                /p:CoverletOutputFormat=cobertura

            continueOnError: false

          - task: PublishTestResults@2
            displayName: "Publish test results"
            inputs:
              testResultsFormat: "VSTest"
              testResultsFiles: "$(Build.SourcesDirectory)/TestResults/*.trx"
              mergeTestResults: true
              failTaskOnFailedTests: true

          - task: PublishCodeCoverageResults@2
            displayName: "Publish code coverage results"
            inputs:
              codeCoverageTool: "Cobertura"
              summaryFileLocation: "$(Build.SourcesDirectory)/TestResults/coverage.cobertura.xml"

          - task: PublishBuildArtifacts@1
            displayName: "Publish merged coverage results"
            inputs:
              PathtoPublish: "$(Build.SourcesDirectory)/TestResults"
              ArtifactName: "coverage"
              publishLocation: "Container"

          - task: PublishTestResults@2
            displayName: "Publish JS test results"
            condition: false # until we can execute, we cannot publish
            inputs:
              testResultsFormat: "JUnit"
              testResultsFiles: "$(Build.SourcesDirectory)/pto.track.tests.js/test-results/jest-junit.xml"
              testRunTitle: "JavaScript Tests"
              mergeTestResults: true
              failTaskOnFailedTests: true

          - task: DotNetCoreCLI@2
            displayName: "Build analyzer tools"
            inputs:
              command: build
              projects: "$(toolsProject)"
              arguments: "--configuration $(buildConfiguration)"

          - task: PowerShell@2
            displayName: "Run analyzer tools"
            inputs:
              targetType: inline
              pwsh: false
              script: |
                $out = "$(Build.SourcesDirectory)\AnalyzerReports"
                New-Item -ItemType Directory -Force -Path $out | Out-Null

                # Path to the built analyzer EXE
                $exe = "$(Build.SourcesDirectory)\tools\metrics-runner\bin\$(buildConfiguration)\net8.0\metrics-runner.exe"


                # Run analyzer and capture output
                & $exe --solution "$(solution)" --output "$out" 2>&1 | Tee-Object "$out\analyzer.log"

                if ($LASTEXITCODE -ne 0) {
                    Write-Error "Analyzer failed with exit code $LASTEXITCODE"
                }

          - task: PublishBuildArtifacts@1
            displayName: "Publish analyzer reports"
            inputs:
              PathtoPublish: "$(Build.SourcesDirectory)/AnalyzerReports"
              ArtifactName: "AnalyzerReports"

      - job: VersioningAndBadges
        dependsOn: BuildAndTest
        condition: |
          and(
            succeeded(),
            eq(variables['Build.SourceBranch'], 'refs/heads/main')
          )
        steps:
          - task: PowerShell@2
            displayName: "Auto-tag patch version"
            inputs:
              targetType: inline
              script: |
                Write-Host "Starting auto-tagging process..."

                # Fetch tags to ensure we have the latest
                git fetch --tags --prune origin
                Write-Host "Fetched remote tags"

                # Check if current commit already has a tag
                $currentTag = git tag --points-at HEAD
                if ($currentTag) {
                    Write-Host "Commit already tagged with $currentTag. Skipping auto-tag."
                    exit 0
                }

                # Get latest version tag (vX.Y.Z)
                $latestTagCommit = git rev-list --tags --max-count=1
                if ($latestTagCommit) {
                    $lastTag = git describe --tags --abbrev=0 --match "v*.*.*" $latestTagCommit 2>$null
                } else {
                    $lastTag = $null
                }

                if (-not $lastTag) {
                    Write-Host "No version tags found. Initializing with v0.1.0"
                    $newTag = "v0.1.0"
                } else {
                    Write-Host "Last tag found: $lastTag"

                    # Parse version
                    $version = $lastTag -replace '^v', ''
                    $parts = $version -split '\.'
                    $major = [int]$parts[0]
                    $minor = [int]$parts[1]
                    $patch = [int]$parts[2]

                    # Increment patch
                    $patch++
                    $newTag = "v$major.$minor.$patch"
                }

                Write-Host "Creating new tag: $newTag"
                git tag -a $newTag -m "Auto-increment patch version"
                git push origin $newTag

                Write-Host "Tag $newTag pushed successfully"
              pwsh: false

          - task: PowerShell@2
            displayName: "Update version badges"
            inputs:
              targetType: inline
              script: |
                Write-Host "Starting badge update..."

                # Fetch tags to ensure we have the latest
                git fetch --tags --prune origin

                # Get latest version tag
                $latestTagCommit = git rev-list --tags --max-count=1
                if (-not $latestTagCommit) {
                    Write-Host "No tags found. Cannot update badges."
                    exit 0
                }

                $versionTag = git describe --tags --abbrev=0 $latestTagCommit 2>$null
                if (-not $versionTag) {
                    Write-Host "Unable to resolve latest tag. Skipping badge update."
                    exit 0
                }

                Write-Host "Latest version tag: $versionTag"

                # Badge directory
                $badgeDir = Join-Path $env:BUILD_SOURCESDIRECTORY "docs/badges"
                if (-not (Test-Path $badgeDir)) {
                    New-Item -ItemType Directory -Path $badgeDir -Force | Out-Null
                }

                # -------------------------
                # Generate SVG badge (ADO-safe)
                # -------------------------
                $svgPath = Join-Path $badgeDir "version.svg"

                $svgLines = @(
                  '<?xml version="1.0" encoding="UTF-8"?>'
                  '<svg xmlns="http://www.w3.org/2000/svg" width="130" height="20" role="img" aria-label="version: ' + $versionTag + '">'
                  '  <linearGradient id="s" x2="0" y2="100%">'
                  '    <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>'
                  '    <stop offset="1" stop-opacity=".1"/>'
                  '  </linearGradient>'
                  '  <mask id="m"><rect width="130" height="20" rx="3" fill="#fff"/></mask>'
                  '  <g mask="url(#m)">'
                  '    <rect width="60" height="20" fill="#555"/>'
                  '    <rect x="60" width="70" height="20" fill="#007ec6"/>'
                  '    <rect width="130" height="20" fill="url(#s)"/>'
                  '  </g>'
                  '  <g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" font-size="11">'
                  '    <text x="30" y="15">version</text>'
                  '    <text x="94" y="15">' + $versionTag + '</text>'
                  '  </g>'
                  '</svg>'
                )

                $svgContent = $svgLines -join "`n"
                Set-Content -Path $svgPath -Value $svgContent -Encoding UTF8

                # -------------------------
                # Generate PNG badge
                # -------------------------
                try {
                    Add-Type -AssemblyName System.Drawing

                    $width = 130; $height = 20
                    $bmp = New-Object System.Drawing.Bitmap($width, $height)
                    $gfx = [System.Drawing.Graphics]::FromImage($bmp)
                    $gfx.SmoothingMode = [System.Drawing.Drawing2D.SmoothingMode]::AntiAlias

                    $leftBrush = New-Object System.Drawing.SolidBrush([System.Drawing.Color]::FromArgb(0x55,0x55,0x55))
                    $rightBrush = New-Object System.Drawing.SolidBrush([System.Drawing.Color]::FromArgb(0x00,0x7e,0xc6))
                    $white = New-Object System.Drawing.SolidBrush([System.Drawing.Color]::White)

                    $gfx.FillRectangle($leftBrush, 0, 0, 60, $height)
                    $gfx.FillRectangle($rightBrush, 60, 0, ($width - 60), $height)

                    $font = New-Object System.Drawing.Font('Verdana', 9)
                    $format = New-Object System.Drawing.StringFormat
                    $format.Alignment = [System.Drawing.StringAlignment]::Center
                    $format.LineAlignment = [System.Drawing.StringAlignment]::Center

                    $gfx.DrawString('version', $font, $white, (New-Object System.Drawing.RectangleF(0,0,60,$height)), $format)
                    $gfx.DrawString($versionTag, $font, $white, (New-Object System.Drawing.RectangleF(60,0,($width-60),$height)), $format)

                    $pngPath = Join-Path $badgeDir "version.png"
                    $bmp.Save($pngPath, [System.Drawing.Imaging.ImageFormat]::Png)

                    $gfx.Dispose(); $bmp.Dispose(); $font.Dispose(); $white.Dispose(); $leftBrush.Dispose(); $rightBrush.Dispose()
                }
                catch {
                    Write-Warning "PNG badge generation failed: $($_.Exception.Message)"
                }

                # -------------------------
                # Commit and push badge updates
                # -------------------------
                git add $badgeDir
                $staged = git diff --name-only --cached

                if ($staged) {
                    $msg = "chore(badges): update version badges to $versionTag [skip ci]"
                    git commit -m $msg
                    git push origin HEAD:main
                    Write-Host "Badge updates pushed to main"
                }
                else {
                    Write-Host "No badge changes detected; skipping commit"
                }

                Write-Host "Badge update complete."
              pwsh: false

  # =====================================================================
  # STAGE: PUBLISH
  # =====================================================================
  - stage: Publish
    dependsOn: Build
    condition: |
      and(
        succeeded(),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          eq(variables['forceDeploy'], 'true')
        )
      )
    displayName: "Publish self-contained app"
    jobs:
      - job: PublishJob
        steps:
          - download: current
            artifact: wwwroot-dist

          - task: PowerShell@2
            displayName: "Restore JS static assets"
            inputs:
              targetType: inline
              script: |
                $distSource = "$env:PIPELINE_WORKSPACE/wwwroot-dist"
                $distDest   = "$(Build.SourcesDirectory)/pto.track/wwwroot/dist"

                Write-Host "Restoring JS static assets..."
                Write-Host "Source: $distSource"
                Write-Host "Destination: $distDest"

                New-Item -ItemType Directory -Force -Path $distDest | Out-Null
                Copy-Item -Recurse -Force "$distSource/*" $distDest
                
                Write-Host "JS static assets restored successfully"
              pwsh: false

          - task: DotNetCoreCLI@2
            displayName: "Publish web app"
            inputs:
              command: publish
              publishWebProjects: false
              projects: "$(webProject)"
              arguments: >
                --configuration $(buildConfiguration)
                --runtime $(runtime)
                --self-contained true
                /p:SkipNpm=true
              zipAfterPublish: false

          - task: PowerShell@2
            displayName: "Stage deploy payload"
            inputs:
              targetType: inline
              script: |
                $appDest     = "$env:BUILD_ARTIFACTSTAGINGDIRECTORY/deploy_payload/app"
                $scriptsDest = "$env:BUILD_ARTIFACTSTAGINGDIRECTORY/deploy_payload/scripts"

                New-Item -ItemType Directory -Force -Path $appDest     | Out-Null
                New-Item -ItemType Directory -Force -Path $scriptsDest | Out-Null

                $publishSource = "$env:BUILD_SOURCESDIRECTORY/pto.track/bin/$env:buildConfiguration/net8.0/$env:runtime/publish"

                Copy-Item -Recurse -Force "$publishSource/*" $appDest

                Copy-Item -Recurse -Force "$env:BUILD_SOURCESDIRECTORY/scripts/*" $scriptsDest
              pwsh: false

          - task: PublishBuildArtifacts@1
            displayName: "Publish deploy payload"
            inputs:
              PathtoPublish: "$(Build.ArtifactStagingDirectory)/deploy_payload"
              ArtifactName: "deploy_payload"

  # =====================================================================
  # STAGE: DEPLOY
  # =====================================================================
  - stage: Deploy
    displayName: "Deploy to IIS via WinRM"
    dependsOn: Publish
    condition: |
      and(
        succeeded(),
        or(
          eq(variables['Build.SourceBranch'], 'refs/heads/main'),
          eq(variables['forceDeploy'], 'true'),
          eq(variables['forceDeploy'], 'True')
        )
      )
    jobs:
      - job: PreflightTarget
        steps:
        - checkout: none

        ###########################################################################
        # 1. VALIDATE SERVICE ACCOUNTS
        ###########################################################################
        - task: PowerShell@2
          displayName: "Preflight: validate service accounts"
          env:
            automationAcctPass: $(automationAcctPass)
            automationAcctName: $(automationAcctName)
            appServiceAccountPassword: $(appServiceAccountPassword)
            webMachineName: $(webMachineName)
          inputs:
            targetType: inline
            pwsh: false
            script: |
              $plainPass  = $env:automationAcctPass
              $userName   = $env:automationAcctName
              $securePass = ConvertTo-SecureString $plainPass -AsPlainText -Force
              $creds      = New-Object System.Management.Automation.PSCredential($userName, $securePass)

              Write-Host "== Connecting to target machine $env:webMachineName =="
              $session = New-PSSession -ComputerName $env:webMachineName -Credential $creds

              Invoke-Command -Session $session -ScriptBlock {
                  param($appSvcAcct, $automationAcctName)

                  Write-Host "== Validating service accounts exist =="

                  function Test-AccountExists {
                      param([string]$AccountName)
                      try {
                          $nt  = New-Object System.Security.Principal.NTAccount($AccountName)
                          $sid = $nt.Translate([System.Security.Principal.SecurityIdentifier])
                          return $true
                      }
                      catch { return $false }
                  }

                  foreach ($acct in @($appSvcAcct, $automationAcctName)) {
                      Write-Host "---- Checking account '$acct' ----"
                      if (-not (Test-AccountExists -AccountName $acct)) {
                          throw "Required account '$acct' does not exist on target machine."
                      }
                  }

                  Write-Host "== All service accounts validated =="
              } -ArgumentList "$(appServiceAccount)", "$(automationAcctName)"

        ###########################################################################
        # 2. PREPARE FOLDER STRUCTURE + ACLs
        ###########################################################################
        - task: PowerShell@2
          displayName: "Preflight: prepare folder structure"
          env:
            automationAcctPass: $(automationAcctPass)
            automationAcctName: $(automationAcctName)
            webMachineName: $(webMachineName)
          inputs:
            targetType: inline
            pwsh: false
            script: |
              $plainPass  = $env:automationAcctPass
              $userName   = $env:automationAcctName
              $securePass = ConvertTo-SecureString $plainPass -AsPlainText -Force
              $creds      = New-Object System.Management.Automation.PSCredential($userName, $securePass)

              $session = New-PSSession -ComputerName $env:webMachineName -Credential $creds

              Invoke-Command -Session $session -ScriptBlock {
                  param($deployRoot, $appSvcAcct, $automationAcctName)

                  Write-Host "== Ensuring folder structure exists =="

                  $paths = @(
                      $deployRoot,
                      "$deployRoot/wwwroot",
                      "$deployRoot/logs"
                  )

                  foreach ($p in $paths) {
                      if (-not (Test-Path $p)) {
                          New-Item -ItemType Directory -Path $p -Force | Out-Null
                      }
                  }

                  Write-Host "== Setting ACLs on deploy root =="

                  $accounts = @($appSvcAcct, $automationAcctName)
                  foreach ($acctName in $accounts) {
                      $acl  = Get-Acl $deployRoot
                      $rule = New-Object System.Security.AccessControl.FileSystemAccessRule(
                          $acctName,
                          "Modify",
                          "ContainerInherit, ObjectInherit",
                          "None",
                          "Allow"
                      )
                      $acl.SetAccessRule($rule)
                      Set-Acl -Path $deployRoot -AclObject $acl
                  }

                  Write-Host "== Folder structure and ACLs applied =="
              } -ArgumentList "$(deploymentFolder)", "$(appServiceAccount)", "$(automationAcctName)"

        ###########################################################################
        # 3. CONFIGURE IIS APP POOL
        ###########################################################################
        - task: PowerShell@2
          displayName: "Preflight: configure IIS app pool"
          env:
            automationAcctPass: $(automationAcctPass)
            automationAcctName: $(automationAcctName)
            appServiceAccountPassword: $(appServiceAccountPassword)
            webMachineName: $(webMachineName)
            connectionString: $(sqlConnectionString)
          inputs:
            targetType: inline
            pwsh: false
            script: |
              $plainPass  = $env:automationAcctPass
              $userName   = $env:automationAcctName
              $securePass = ConvertTo-SecureString $plainPass -AsPlainText -Force
              $creds      = New-Object System.Management.Automation.PSCredential($userName, $securePass)

              # SQL connection string as SecureString for transport
              $secureConn = ConvertTo-SecureString $env:connectionString -AsPlainText -Force

              $session = New-PSSession -ComputerName $env:webMachineName -Credential $creds

              Invoke-Command -Session $session -ScriptBlock {
                  param(
                    $appPoolName,
                    $appSvcAcct,
                    $appSvcPass,
                    $aspNetCoreEnv,
                    $sqlConnSecure
                  )

                  Import-Module WebAdministration

                  $sqlConnString = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
                      [Runtime.InteropServices.Marshal]::SecureStringToBSTR($sqlConnSecure)
                  )

                  Write-Host "== Ensuring IIS app pool exists =="
                  if (-not (Test-Path "IIS:\AppPools\$appPoolName")) {
                      New-WebAppPool -Name $appPoolName | Out-Null
                      Write-Host "---- Created app pool '$appPoolName'"
                  } else {
                      Write-Host "---- App pool '$appPoolName' already exists"
                  }

                  Write-Host "== Stopping app pool before identity change =="
                  try { Stop-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue } catch {}

                  Write-Host "== Setting app pool identity =="
                  Write-Host "---- Target identity: $appSvcAcct"

                  # Correct ordering: username → password → identityType
                  Set-ItemProperty "IIS:\AppPools\$appPoolName" -Name processModel.userName   -Value $appSvcAcct
                  Set-ItemProperty "IIS:\AppPools\$appPoolName" -Name processModel.password   -Value $appSvcPass
                  Set-ItemProperty "IIS:\AppPools\$appPoolName" -Name processModel.identityType -Value 3

                  Write-Host "== Starting app pool after identity change =="
                  Start-WebAppPool -Name $appPoolName

                  Write-Host "== Ensuring App Pool environment variables =="

                  function Set-AppPoolEnvVar {
                      param(
                          [string]$PoolName,
                          [string]$VarName,
                          [string]$VarValue
                      )

                      $filter = "system.applicationHost/applicationPools/add[@name='$PoolName']/environmentVariables"

                      $existing = Get-WebConfigurationProperty -pspath 'MACHINE/WEBROOT/APPHOST' `
                          -filter "$filter/add[@name='$VarName']" -name "value" -ErrorAction SilentlyContinue

                      if ($existing) {
                          Write-Host "---- Updating existing env var '$VarName'"
                          Set-WebConfigurationProperty -pspath 'MACHINE/WEBROOT/APPHOST' `
                              -filter "$filter/add[@name='$VarName']" `
                              -name "value" `
                              -value $VarValue
                      }
                      else {
                          Write-Host "---- Creating env var '$VarName'"
                          Add-WebConfigurationProperty -pspath 'MACHINE/WEBROOT/APPHOST' `
                              -filter $filter `
                              -name "." `
                              -value @{ name=$VarName; value=$VarValue }
                      }
                  }

                  Set-AppPoolEnvVar -PoolName $appPoolName -VarName "ASPNETCORE_ENVIRONMENT" -VarValue $aspNetCoreEnv
                  Set-AppPoolEnvVar -PoolName $appPoolName -VarName "ConnectionStrings__PtoTrackDbContext" -VarValue $sqlConnString

                  Write-Host "== App Pool environment variables applied =="
              } -ArgumentList "$(appPoolName)", "$(appServiceAccount)", $env:appServiceAccountPassword, "$(pto-track-env)", $secureConn

        ###########################################################################
        # 4. CONFIGURE WEBSITE + BINDINGS
        ###########################################################################
        - task: PowerShell@2
          displayName: "Preflight: configure IIS website and bindings"
          env:
            automationAcctPass: $(automationAcctPass)
            automationAcctName: $(automationAcctName)
            webMachineName: $(webMachineName)
          inputs:
            targetType: inline
            pwsh: false
            script: |
              $plainPass  = $env:automationAcctPass
              $userName   = $env:automationAcctName
              $securePass = ConvertTo-SecureString $plainPass -AsPlainText -Force
              $creds      = New-Object System.Management.Automation.PSCredential($userName, $securePass)

              $session = New-PSSession -ComputerName $env:webMachineName -Credential $creds

              Invoke-Command -Session $session -ScriptBlock {
                  param(
                    $websiteName,
                    $deployRoot,
                    $appPoolName,
                    $hostname,
                    $certThumbprint
                  )

                  Import-Module WebAdministration

                  Write-Host "== Ensuring IIS website '$websiteName' exists =="

                  if (-not (Test-Path "IIS:\Sites\$websiteName")) {
                      Write-Host "---- Creating new website '$websiteName'"
                      New-Website -Name $websiteName -PhysicalPath $deployRoot -ApplicationPool $appPoolName | Out-Null
                  } else {
                      Write-Host "---- Website '$websiteName' already exists"
                      Set-ItemProperty "IIS:\Sites\$websiteName" -Name physicalPath   -Value $deployRoot
                      Set-ItemProperty "IIS:\Sites\$websiteName" -Name applicationPool -Value $appPoolName
                  }

                  Write-Host "== Configuring HTTP binding (port 80) =="
                  $httpBinding = Get-WebBinding -Name $websiteName -Protocol "http" -Port 80 -HostHeader $hostname -ErrorAction SilentlyContinue
                  if (-not $httpBinding) {
                      New-WebBinding -Name $websiteName -Protocol "http" -Port 80 -HostHeader $hostname
                  }

                  Write-Host "== Configuring HTTPS binding (port 443) =="
                  $httpsBinding = Get-WebBinding -Name $websiteName -Protocol "https" -Port 443 -HostHeader $hostname -ErrorAction SilentlyContinue
                  if (-not $httpsBinding) {
                      New-WebBinding -Name $websiteName -Protocol "https" -Port 443 -HostHeader $hostname
                  }

                  Write-Host "== Associating SSL certificate with HTTPS binding =="
                  $binding = Get-WebBinding -Name $websiteName -Protocol "https" -Port 443 -HostHeader $hostname
                  $binding.AddSslCertificate($certThumbprint, "WebHosting")

                  Write-Host "== Starting website if stopped =="
                  if ((Get-WebsiteState -Name $websiteName).Value -ne "Started") {
                      Start-Website -Name $websiteName
                  }

                  Write-Host "== IIS website and bindings configured =="
              } -ArgumentList "$(websiteName)", "$(deploymentFolder)", "$(appPoolName)", "$(webServer)", "$(certificateThumbprint)"

        ###########################################################################
        # 5. VALIDATE AUTHENTICATION CONFIGURATION
        ###########################################################################
        - task: PowerShell@2
          displayName: "Preflight: validate authentication configuration"
          env:
            automationAcctPass: $(automationAcctPass)
            automationAcctName: $(automationAcctName)
            webMachineName: $(webMachineName)
          inputs:
            targetType: inline
            pwsh: false
            script: |
              $plainPass  = $env:automationAcctPass
              $userName   = $env:automationAcctName
              $securePass = ConvertTo-SecureString $plainPass -AsPlainText -Force
              $creds      = New-Object System.Management.Automation.PSCredential($userName, $securePass)

              $session = New-PSSession -ComputerName $env:webMachineName -Credential $creds

              Invoke-Command -Session $session -ScriptBlock {
                  Import-Module WebAdministration

                  Write-Host "== Validating authentication configuration in applicationHost.config =="

                  $errors = @()

                  Write-Host "---- Checking Windows Authentication ----"
                  $winAuthOverride = Get-WebConfiguration `
                      -pspath 'MACHINE/WEBROOT/APPHOST' `
                      -filter 'system.webServer/security/authentication/windowsAuthentication' |
                      Select-Object -ExpandProperty OverrideMode -ErrorAction SilentlyContinue

                  if ($winAuthOverride -eq 'Deny') {
                      $errors += "Windows Authentication overrideMode='Deny'."
                  }

                  Write-Host "---- Checking Anonymous Authentication ----"
                  $anonAuthOverride = Get-WebConfiguration `
                      -pspath 'MACHINE/WEBROOT/APPHOST' `
                      -filter 'system.webServer/security/authentication/anonymousAuthentication' |
                      Select-Object -ExpandProperty OverrideMode -ErrorAction SilentlyContinue

                  if ($anonAuthOverride -eq 'Deny') {
                      $errors += "Anonymous Authentication overrideMode='Deny'."
                  }

                  if ($errors.Count -gt 0) {
                      foreach ($err in $errors) { Write-Host "ERROR: $err" -ForegroundColor Red }
                      throw "Authentication configuration validation failed."
                  }

                  Write-Host "== Authentication configuration validated successfully =="
              }

      - job: DeployJob
        dependsOn: PreflightTarget
        steps:
          - checkout: none

          - download: current
            artifact: deploy_payload

          - task: PowerShell@2
            displayName: "Deploy scripts to target"
            env:
              automationAcctPass: $(automationAcctPass)
              automationAcctName: $(automationAcctName)
              webMachineName: $(webMachineName)
            inputs:
              targetType: inline
              script: |
                  $plainPass  = $env:automationAcctPass
                  $userName   = $env:automationAcctName
                  $securePass = ConvertTo-SecureString $plainPass -AsPlainText -Force
                  $creds      = New-Object System.Management.Automation.PSCredential($userName, $securePass)
                  $session    = New-PSSession -ComputerName $env:webMachineName -Credential $creds

                  $scriptsSource = "$env:PIPELINE_WORKSPACE/deploy_payload/scripts/*"
                  $scriptsDest   = "$env:deploymentFolder/scripts"

                  Invoke-Command -Session $session -ScriptBlock {
                      param($dest)
                      if (-not (Test-Path $dest)) {
                          New-Item -ItemType Directory -Path $dest -Force | Out-Null
                      }
                  } -ArgumentList $scriptsDest

                  Copy-Item -Path $scriptsSource -Destination $scriptsDest -Recurse -Force -ToSession $session
              pwsh: false

          - task: PowerShell@2
            displayName: "Deploy app to target"
            env:
              automationAcctPass: $(automationAcctPass)
              automationAcctName: $(automationAcctName)
              webMachineName: $(webMachineName)
            inputs:
              targetType: inline
              script: |
                  $plainPass  = $env:automationAcctPass
                  $userName   = $env:automationAcctName
                  $securePass = ConvertTo-SecureString $plainPass -AsPlainText -Force
                  $creds      = New-Object System.Management.Automation.PSCredential($userName, $securePass)
                  $session    = New-PSSession -ComputerName $env:webMachineName -Credential $creds

                  $appSource = "$env:PIPELINE_WORKSPACE/deploy_payload/app/*"
                  $appDest   = $env:deploymentFolder

                  Copy-Item -Path $appSource -Destination $appDest -Recurse -Force -ToSession $session

                  Invoke-Command -Session $session -ScriptBlock {
                      param($appPoolName)
                      Import-Module WebAdministration
                      Restart-WebAppPool -Name $appPoolName
                  } -ArgumentList $(appPoolName)
              pwsh: false

  - stage: PostDeployChecks
    displayName: "Post-deployment health checks"
    dependsOn: Deploy
    condition: succeeded()   # only run if deploy succeeded
  
    jobs:
      - job: HealthChecks
        condition: false # see rant job
        displayName: "Run health checks from build agent"
        steps:
          - checkout: none

          - task: PowerShell@2
            displayName: "Health check (live)"
            inputs:
              targetType: inline
              pwsh: false
              script: |
                  Write-Host "Checking live health at $env:healthUrl"
                  $resp = Invoke-WebRequest -Uri "$(healthUrl)" -UseBasicParsing -TimeoutSec 30
                  if ($resp.StatusCode -ne 200) {
                      throw "Live health check failed with status code $($resp.StatusCode)"
                  }
                  Write-Host "Status: $($resp.StatusCode)"
                  Write-Host "Response:"
                  Write-Host $resp.Content

          - task: PowerShell@2
            displayName: "Health check (ready)"
            inputs:
              targetType: inline
              pwsh: false
              script: |
                  if ($env:checkReady -ne "true" -and $env:checkReady -ne "True") {
                      Write-Host "checkReady is not true; skipping ready health check."
                      return
                  }

                  Write-Host "Checking ready health at $env:readyHealthUrl"
                  $resp = Invoke-WebRequest -Uri "$(readyHealthUrl) -UseBasicParsing -TimeoutSec 30
                  if ($resp.StatusCode -ne 200) {
                      throw "Ready health check failed with status code $($resp.StatusCode)"
                  }
                  Write-Host "Status: $($resp.StatusCode)"
                  Write-Host "Response:"
                  Write-Host $resp.Content

      - job: HealthChecksRant
        steps:
          - task: PowerShell@2
            displayName: "Health check rant"
            inputs:
              targetType: inline
              pwsh: false
              script: |

                Write-Host "***************************RANT START***************************"
                Write-Host "Health checks cannot currently be conducted!!!"
                Write-Host "But, why, you ask?  Good question.  Technical reason follows:"
                Write-Host "The target machine has all network profiles disabled.  This means"
                Write-Host "that none of the inbound firewall rules (that allow HTTP/S traffic)"
                Write-Host "are applied.  Which means what? The server cannot call itself on"
                Write-Host "HTTP/S.  Call it from the build server instead, you ask?  Great idea!"
                Write-Host "Except, Illumio blocks outbound HTTP/S traffice from the build"
                Write-Host "server - connections for pipeline are open over WinRM (port 5985)"
                Write-Host "but not on port 80/443.  Health checks should be completed manually at:"
                Write-Host "http/s: pto-track.corp.asbhawaii.com/health/live"
                Write-Host "http/s: pto-track.corp.asbhawaii.com/health/ready."
